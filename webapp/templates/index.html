<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPS ML Game</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/experimental-theme.css') }}">
    <style>
        .disabled-notification {
            position: fixed; top: 20px; right: 20px; z-index: 9999;
            background: #ff6b6b; color: white; padding: 12px 20px;
            border-radius: 8px; font-weight: 500; box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            animation: slideInRight 0.3s ease;
        }
        
        /* Confidence Toggle Styling */
        .confidence-toggle {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
            font-size: 12px;
        }
        .confidence-info {
            color: #e2e8f0;
            font-weight: bold;
            margin-right: 10px;
        }
        .confidence-option {
            display: flex;
            align-items: center;
            gap: 5px;
            color: #f8fafc;
            cursor: pointer;
        }
        .confidence-option input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .endgame-summary {
            display: none;
            margin-top: 24px;
            padding: 24px;
            border-radius: 16px;
            background: linear-gradient(135deg, rgba(26, 32, 44, 0.95) 0%, rgba(17, 24, 39, 0.95) 100%);
            border: 2px solid rgba(99, 102, 241, 0.4);
            box-shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
            color: #e2e8f0;
        }

        .endgame-summary.visible {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .endgame-summary h2 {
            margin: 0 0 8px;
            font-size: 1.6em;
            color: #a5b4ff;
        }

        .endgame-summary .summary-subtitle {
            margin: 0 0 16px;
            color: rgba(226, 232, 240, 0.75);
        }

        .endgame-summary .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }

        .endgame-summary .summary-card {
            background: rgba(79, 70, 229, 0.12);
            border: 1px solid rgba(129, 140, 248, 0.3);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
        }

        .endgame-summary .summary-value {
            font-size: 1.8em;
            font-weight: 700;
            color: #c7d2fe;
        }

        .endgame-summary .summary-label {
            font-size: 0.9em;
            color: rgba(226, 232, 240, 0.75);
            margin-top: 6px;
        }

        .endgame-summary .summary-section {
            margin-top: 20px;
        }

        .endgame-summary .summary-section h3 {
            margin: 0 0 12px;
            font-size: 1.1em;
            color: #c7d2fe;
        }

        .endgame-summary .summary-text {
            background: rgba(79, 70, 229, 0.1);
            border: 1px solid rgba(129, 140, 248, 0.2);
            border-radius: 10px;
            padding: 14px;
            line-height: 1.6;
        }

        .endgame-summary .summary-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-top: 24px;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .endgame-summary .summary-winner {
            margin-top: 8px;
            font-weight: 600;
            color: #fbbf24;
        }

        .conversation-callout {
            margin-top: 12px;
            padding: 10px 14px;
            border-radius: 10px;
            background: rgba(74, 222, 128, 0.12);
            border: 1px solid rgba(74, 222, 128, 0.35);
            color: #bbf7d0;
            font-weight: 600;
            display: none;
        }

        .conversation-callout.visible {
            display: block;
            animation: fadeIn 0.25s ease;
        }
        
        /* Coaching Interface Styles */
        .coach-content {
            padding: 20px;
        }
        
        .coach-tips-section, .coach-stats-section {
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(15, 23, 42, 0.3);
            border-radius: 12px;
            border: 1px solid rgba(34, 197, 94, 0.2);
        }
        
        .coach-tips-section h3, .coach-stats-section h3 {
            color: #22c55e;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        #coaching-tips-container {
            min-height: 120px;
            margin-bottom: 15px;
        }
        
        .coaching-tip {
            background: rgba(34, 197, 94, 0.1);
            border: 1px solid rgba(34, 197, 94, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            color: #e2e8f0;
        }
        
        .coaching-tip.priority-high {
            border-color: rgba(239, 68, 68, 0.5);
            background: rgba(239, 68, 68, 0.1);
        }
        
        .coaching-tip.priority-medium {
            border-color: rgba(251, 191, 36, 0.5);
            background: rgba(251, 191, 36, 0.1);
        }
        
        .coaching-tip.priority-low {
            border-color: rgba(34, 197, 94, 0.3);
            background: rgba(34, 197, 94, 0.1);
        }
        
        .coaching-tip-priority {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 5px;
        }
        
        .coaching-tip-placeholder {
            text-align: center;
            color: #94a3b8;
            padding: 30px;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(34, 197, 94, 0.1);
        }
        
        .stat-item:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #cbd5e1;
        }
        
        .stat-value {
            color: #22c55e;
            font-weight: 600;
        }
        
        #refresh-coaching-tips {
            width: 100%;
            margin-top: 10px;
        }
        
        /* Performance Charts Styling */
        .performance-chart-wrapper {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(34, 197, 94, 0.3);
        }
        
        .performance-chart-wrapper h4 {
            color: #22c55e;
            margin-bottom: 10px;
            font-size: 1rem;
        }
        
        .current-stats {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }
        
        /* LLM Banter Toggle Styling */
        .select-card label[for="llm-banter-toggle"] {
            background: linear-gradient(135deg, #6366f1, #8b5cf6);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 600;
        }
    </style>
</head>
<body class="experimental-ui">
    <div class="app-wrapper personality-theme" id="app-root">
        <div class="app-content">
            <header class="app-header">
                <div class="app-title-group">
                    <h1 class="app-title">RPS ML Arena</h1>
                    <p class="app-subtitle">Challenge adaptive AI opponents with live analytics, coaching intelligence, and cinematic battle visuals.</p>
                    <div class="badge-deck">
                        <span class="badge">üß† Adaptive ML</span>
                        <span class="badge">üìà Live Analytics</span>
                        <span class="badge">ü§ñ Personality Engine</span>
                    </div>
                </div>
                <div class="header-actions">
                    <button class="pill-button gradient-primary" onclick="window.open('/developer', '_blank')">Developer Console</button>
                    <button class="pill-button gradient-info" onclick="window.open('/performance', '_blank')">Performance Dashboard</button>
                    <button class="pill-button gradient-success" onclick="showDeveloperMetrics()">Developer Metrics</button>
                    <button class="pill-button gradient-danger" onclick="resetGame()">Reset Game</button>
                    <!-- This is for Debug only -->
                    <button class="pill-button gradient-info" onclick="downloadGameContext()">Download Game Context (Debug)</button>
                </div>
            </header>

            <div class="page-structure">
                <section class="panel top-intel" id="top-intel">
                    <nav class="mode-switcher top-switcher" aria-label="Summary Switcher">
                        <button class="mode-tab" data-mode="top-overview">üìä Overview</button>
                        <button class="mode-tab active" data-mode="top-controls">üéõÔ∏è Controls</button>
                    </nav>
                    <div class="mode-panels top-panels">
                        <div class="mode-panel" data-mode="top-overview">
                            <div class="hero-summary-grid">
                                <div class="hero-summary-block hero-strategy">
                                    <div class="summary-heading">
                                        <h2 class="panel-title">Adaptive Strategy Monitor</h2>
                                        <span class="panel-subtitle">Live look at how the AI is approaching the next round.</span>
                                    </div>
                                    <div class="status-value">
                                        Current Strategy: <span id="current-strategy-text">Analyzing...</span>
                                    </div>
                                </div>
                                <div class="hero-summary-block hero-scoreboard">
                                    <div class="summary-heading">
                                        <h2 class="panel-title">Match Scoreboard</h2>
                                        <span class="panel-subtitle">Keep tabs on the overall duel momentum.</span>
                                    </div>
                                    <div class="stat-grid">
                                        <div class="stat-card">
                                            <h4>Rounds</h4>
                                            <div id="rounds" class="stat-value">{{ round }}</div>
                                        </div>
                                        <div class="stat-card">
                                            <h4>Your Wins</h4>
                                            <div id="human-wins" class="stat-value">{{ stats.human_win }}</div>
                                        </div>
                                        <div class="stat-card">
                                            <h4>Computer Wins</h4>
                                            <div id="robot-wins" class="stat-value">{{ stats.robot_win }}</div>
                                        </div>
                                        <div class="stat-card">
                                            <h4>Ties</h4>
                                            <div id="ties" class="stat-value">{{ stats.tie }}</div>
                                        </div>
                                    </div>
                                </div>
                                <div class="hero-summary-block hero-alerts">
                                    <div class="summary-heading">
                                        <h2 class="panel-title">Live Alerts</h2>
                                        <span class="panel-subtitle">We flag pattern shifts and strategy cues for you.</span>
                                    </div>
                                    <div id="alert-feed" class="alert-feed">
                                        <div class="alert-chip muted">Play a round to populate insights.</div>
                                    </div>
                                </div>
                            </div>
                            <div class="overview-insights">
                                <div class="overview-section">
                                    <h3 class="overview-title">Full Game Snapshot</h3>
                                    <div class="overview-grid">
                                        <div class="overview-card">
                                            <span class="label">Rounds</span>
                                            <span class="value" id="overview-total-rounds">0</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Human Win Rate</span>
                                            <span class="value" id="overview-human-winrate">--%</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Robot Win Rate</span>
                                            <span class="value" id="overview-robot-winrate">--%</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Tie Rate</span>
                                            <span class="value" id="overview-tie-rate">--%</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Longest Your Streak</span>
                                            <span class="value" id="overview-longest-human">--</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Longest Robot Streak</span>
                                            <span class="value" id="overview-longest-robot">--</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Most Common Move</span>
                                            <span class="value" id="overview-common-move">--</span>
                                        </div>
                                        <!-- AI Prediction Accuracy box fully removed as requested -->
                                    </div>
                                </div>
                                <div class="overview-section">
                                    <h3 class="overview-title">Recent Momentum (Last 10)</h3>
                                    <div class="overview-grid">
                                        <div class="overview-card">
                                            <span class="label">Recent Win Rate</span>
                                            <span class="value" id="overview-recent-winrate">--%</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Current Streak</span>
                                            <span class="value" id="overview-current-streak">--</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Recent Bias</span>
                                            <span class="value" id="overview-recent-move">--</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">Score Differential</span>
                                            <span class="value" id="overview-score-diff">0</span>
                                        </div>
                                        <div class="overview-card">
                                            <span class="label">AI Confidence</span>
                                            <span class="value" id="overview-ai-confidence">--%</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="overview-section">
                                    <h3 class="overview-title">Strategic Intelligence</h3>
                                    <div class="overview-grid">
                                        <div class="overview-card wide">
                                            <span class="label" title="Measures how predictable your moves are based on patterns. Lower values (0-40%) mean you're harder to predict, higher values (60%+) mean the AI can read your patterns easily.">Predictability Score ‚ìò</span>
                                            <span class="value" id="overview-predictability">--</span>
                                            <span class="hint">Lower is better for humans</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="overview-summary" id="overview-recommendation">Awaiting gameplay data...</div>
                            </div>
                        </div>
                        <div class="mode-panel active" data-mode="top-controls">
                            <div class="control-grid">
                                <div class="control-row">
                                    <div class="select-card">
                                        <label for="difficulty">üéØ AI Difficulty</label>
                                        <select id="difficulty" onchange="setDifficulty()">
                                            <option value="rookie">üü¢ Rookie (Beginner)</option>
                                            <option value="challenger" selected>üü° Challenger (Intermediate)</option>
                                            <option value="master">üî¥ Master (Advanced)</option>
                                        </select>
                                    </div>
                                    <div class="select-card">
                                        <label for="strategy">‚öîÔ∏è AI Strategy</label>
                                        <select id="strategy" onchange="setStrategy()">
                                            <option value="to_win" selected>üó°Ô∏è To Win (Aggressive)</option>
                                            <option value="not_to_lose">üõ°Ô∏è Not to Lose (Defensive)</option>
                                        </select>
                                    </div>
                                    <div class="select-card">
                                        <label for="personality">ü§ñ AI Personality</label>
                                        <select id="personality" onchange="setPersonality()">
                                            <option value="neutral" selected>üòê Neutral (Balanced)</option>
                                            <option value="aggressive">‚öîÔ∏è Aggressive (High-risk)</option>
                                            <option value="defensive">üõ°Ô∏è Defensive (Risk-averse)</option>
                                            <option value="unpredictable">üé≤ Unpredictable (Erratic)</option>
                                            <option value="cautious">ÔøΩ Cautious (Methodical)</option>
                                            <option value="confident">üí™ Confident (Bold)</option>
                                            <option value="chameleon">ÔøΩ Chameleon (Adaptive)</option>
                                        </select>
                                    </div>
                                    <div class="select-card">
                                        <label for="game-length">‚è±Ô∏è Game Length</label>
                                        <select id="game-length" onchange="setGameLength()">
                                            <option value="25" selected>25 Moves</option>
                                            <option value="50">50 Moves</option>
                                            <option value="100">100 Moves</option>
                                            <option value="250">250 Moves</option>
                                            <option value="500">500 Moves</option>
                                            <option value="1000">1000 Moves</option>
                                            <option value="infinite">Infinite</option>
                                        </select>
                                    </div>
                                    <div class="select-card">
                                        <label for="llm-banter-toggle">üß† Banter Mode</label>
                                        <select id="llm-banter-toggle" onchange="setLLMBanterMode()">
                                            <option value="false" selected>üîß Rule-based (Default)</option>
                                            <option value="true">ü§ñ AI-Generated (LLM)</option>
                                        </select>
                                    </div>
                                    <!-- This is for Debug only -->
                                    <div class="select-card">
                                        <button id="start-lock-controls" class="pill-button gradient-danger" style="display: flex; justify-content: center; align-items: center; width: 100%;" onclick="lockControls()"><span style="margin: 0 auto;">Start</span></button>
                                    </div>
                                </div>
                            </div>
                            <!-- Buttons moved to header-actions -->
                            <div id="robot-character-display" class="robot-profile">
                                <div id="robot-avatar" class="robot-avatar">
                                    <span class="avatar-emoji">ü§ñ</span>
                                    <div id="strategy-symbol" class="strategy-icon">‚öîÔ∏è</div>
                                </div>
                                <div class="robot-meta">
                                    <div class="meta-title"><span id="robot-name">Standard Robot</span></div>
                                    <div class="meta-tags">
                                        <span class="tag">Difficulty: <span id="robot-difficulty">Easy</span></span>
                                        <span class="tag">Strategy: <span id="robot-strategy">Challenger</span></span>
                                        <span class="tag">Personality: <span id="robot-personality">Balanced</span></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>

                <div class="bottom-grid">
                    <section class="panel combat-cluster" id="battle-console">
                        <div class="combat-stack">
                            <div class="conversation-wrapper">
                                <div id="robot-conversation" class="conversation-panel">
                                    <div class="conversation-heading">
                                        <h3>AI Comms Channel</h3>
                                        <span>Live banter from your opponent.</span>
                                    </div>
                                    <div class="conversation-body">
                                        <div id="conversation-avatar" class="conversation-avatar">ü§ñ</div>
                                        <div class="conversation-content">
                                            <div class="speech-bubble">
                                                <div id="robot-speech">"Ready for battle? Let's see what you've got!"</div>
                                                <span class="speech-tail"></span>
                                            </div>
                                        <div class="conversation-meta">
                                            <span id="robot-mood">üòé Confident</span>
                                        </div>
                                        <div id="player-performance-callout" class="conversation-callout" aria-live="polite"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="move-display-window" class="move-display">
                                <div id="human-move-display" class="move-display-card">
                                    <h3 class="move-title">You</h3>
                                    <div class="move-visual">
                                        <img id="human-move-img" src="/static/paper.png" alt="Your Move" style="display: none;">
                                        <span id="human-move-text">Choose your move</span>
                                    </div>
                                </div>
                                <div id="robot-move-display" class="move-display-card">
                                    <h3 class="move-title">Robot</h3>
                                    <div class="move-visual">
                                        <img id="robot-move-img" src="/static/paper.png" alt="Robot Move" style="display: none;">
                                        <span id="robot-move-text">Thinking...</span>
                                    </div>
                                </div>
                                <div class="move-display-card vs-card">
                                    <div id="round-result" class="round-result" style="display: none;">Round Result</div>
                                </div>
                            </div>
                            <div id="result" class="result-banner">
                                Press buttons or use A, W, D keys to play!
                            </div>
                            <div id="endgame-summary-panel" class="endgame-summary" aria-live="polite"></div>
                            <div class="move-pad">
                                <button type="button" id="move-paper" class="move-btn" onclick="submitMove('paper')" disabled>Paper (P)</button>
                                <button type="button" id="move-rock" class="move-btn" onclick="submitMove('rock')" disabled>Rock (R)</button>
                                <button type="button" id="move-scissors" class="move-btn" onclick="submitMove('scissors')" disabled>Scissors (S)</button>
                            </div>
                        </div>
                    </section>

                    <section class="panel intel-cluster">
                        <nav class="mode-switcher intel-switcher" aria-label="Insight Switcher">
                            <button class="mode-tab active" data-mode="analytics">üìà Analytics View</button>
                            <button class="mode-tab" data-mode="coach">üéì Coach View</button>
                        </nav>
                        <div class="mode-panels intel-panels">
                            <div class="mode-panel active" data-mode="analytics">
                                <section class="panel analytics-panel">
                                    <div class="panel-heading">
                                        <h2 class="panel-title">üìà Analytics View</h2>
                                        <span class="panel-subtitle">Analytics functionality has been simplified.</span>
                                    </div>
                                    <div style="text-align: center; padding: 40px; color: #94a3b8;">
                                        <h3>üöß Analytics Under Maintenance</h3>
                                        <p>Analytics objects and chart metrics have been temporarily removed for system optimization.</p>
                                        <p>Basic game functionality remains fully operational.</p>
                                    </div>
                                </section>
                            </div>

                            <div class="mode-panel" data-mode="coach">
                                <section class="panel coach-panel">
                                    <div class="panel-heading">
                                        <h2 class="panel-title">üéì Coach View</h2>
                                        <span class="panel-subtitle">AI-powered strategic coaching with professor personality.</span>
                                    </div>
                                    <div class="coach-content">
                                        <div class="coach-tips-section">
                                            <h3>üß† Strategic Coaching Tips</h3>
                                            <div id="coaching-tips-container">
                                                <div class="coaching-tip-placeholder">
                                                    <p>üéÆ Start playing to receive personalized coaching tips!</p>
                                                    <p>Tips will analyze your recent moves and provide strategic guidance.</p>
                                                </div>
                                            </div>
                                            <button id="refresh-coaching-tips" class="btn primary">üîÑ Get New Tips</button>
                                        </div>
                                        
                                        <div class="coach-stats-section">
                                            <h3>üìä Performance Analysis</h3>
                                            <div id="performance-charts-container">
                                                <div class="performance-chart-wrapper">
                                                    <h4>Predictability Over Time</h4>
                                                    <canvas id="predictability-chart" width="400" height="200"></canvas>
                                                </div>
                                                <div class="performance-chart-wrapper">
                                                    <h4 title="Shows how strongly the AI detects repeating patterns in your play. Higher values mean clearer patterns that the AI can exploit.">Pattern Strength Timeline ‚ìò</h4>
                                                    <canvas id="pattern-chart" width="400" height="200"></canvas>
                                                </div>
                                                <div class="performance-chart-wrapper">
                                                    <h4 title="Measures how quickly the AI adapts its strategy to counter your moves. Higher rates mean the AI is learning and adjusting faster.">Adaptation Rate Progress ‚ìò</h4>
                                                    <canvas id="adaptation-chart" width="400" height="200"></canvas>
                                                </div>
                                            </div>
                                            <div class="current-stats">
                                                <div class="stat-item">
                                                    <span class="stat-label" title="Real-time measure of how predictable your current move pattern is. Lower = harder to predict.">Current Predictability ‚ìò:</span>
                                                    <span id="current-predictability" class="stat-value">-</span>
                                                </div>
                                                <div class="stat-item">
                                                    <span class="stat-label" title="Strength of detectable patterns in your recent moves. Scale 0-1, where 1 means very strong patterns.">Current Pattern Strength ‚ìò:</span>
                                                    <span id="current-pattern" class="stat-value">-</span>
                                                </div>
                                                <div class="stat-item">
                                                    <span class="stat-label" title="How rapidly the AI is currently adjusting its prediction strategy based on your moves.">Current Adaptation Rate ‚ìò:</span>
                                                    <span id="current-adaptation" class="stat-value">-</span>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </section>
                            </div>
                        </div>
                    </section>
                </div>
            </div>
        </div>
    </div>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
    // This is for Debug only
    let gameStarted = false;
    function lockControls() {
        document.getElementById('difficulty').disabled = true;
        document.getElementById('strategy').disabled = true;
        document.getElementById('personality').disabled = true;
        document.getElementById('game-length').disabled = true;
        document.getElementById('start-lock-controls').disabled = true;
        document.getElementById('start-lock-controls').classList.remove('gradient-danger');
        document.getElementById('start-lock-controls').classList.add('gradient-success');
        // Enable move buttons
        document.getElementById('move-paper').disabled = false;
        document.getElementById('move-rock').disabled = false;
        document.getElementById('move-scissors').disabled = false;
        gameStarted = true;
        // Notify backend to start recording
        // Send selected game length to backend
        const gameLengthSelect = document.getElementById('game-length');
        const selectedGameLength = gameLengthSelect ? gameLengthSelect.value : '25';
        fetch('/start_recording', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ game_length: selectedGameLength })
        });
    }
    // On page load, ensure move buttons are disabled until Start is clicked
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('move-paper').disabled = true;
        document.getElementById('move-rock').disabled = true;
        document.getElementById('move-scissors').disabled = true;
        gameStarted = false;
        document.getElementById('start-lock-controls').classList.remove('gradient-success');
        document.getElementById('start-lock-controls').classList.add('gradient-danger');
        
        // Initialize performance charts
        initializePerformanceCharts();
    });
    // Only allow keyboard move input after Start is clicked
    document.addEventListener('keydown', function(e) {
        if (!gameStarted) return;
        if (e.repeat) return; // Prevent holding key from triggering multiple moves
        if (e.key === 'p' || e.key === 'P') submitMove('paper');
        else if (e.key === 'r' || e.key === 'R') submitMove('rock');
        else if (e.key === 's' || e.key === 'S') submitMove('scissors');
    });
    // Gate submitMove so it cannot be called before gameStarted
    const originalSubmitMove = window.submitMove;
    window.submitMove = function(move) {
        if (!gameStarted) return;
        originalSubmitMove(move);
    }
    // This is for Debug only
    function downloadGameContext() {
        fetch('/download_game_context')
            .then(response => response.json())
            .then(data => {
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'game_context.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
    }
        console.log('Main page script loading...');
        
        // Global variables (will be updated from dropdown values on page load)
    let currentDifficulty = 'challenger';  // Default to challenger difficulty
    let currentStrategy = 'balanced';  // Default fallback (mildest)
    let currentPersonality = 'neutral';  // Default fallback (mildest)
    let useLLMBanter = false;  // Default to rule-based banter (not LLM)
        
        // Chart variables
        let moveDistributionChart = null;
        let winRateTrendChart = null;
        let scoreDifferentialChart = null;
        let modelPredictionChart = null;
        let modelAccuracyChart = null;
        let confidenceTrendChart = null;

        let currentGameLimit = null; // Will be set from dropdown on page load
        let isGameFrozen = false;
        let endgameSummaryShown = false;
        let defaultResultMessage = '';
        
        // Initialize charts when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing charts...');
            
            // Get actual dropdown values instead of relying on template variables
            currentDifficulty = document.getElementById('difficulty').value;
            currentStrategy = document.getElementById('strategy').value;
            currentPersonality = document.getElementById('personality').value;
            
            // Initialize LLM banter toggle (default to rule-based)
            const llmToggle = document.getElementById('llm-banter-toggle');
            useLLMBanter = llmToggle.value === 'true';
            
            console.log('Initial dropdown values:', {
                difficulty: currentDifficulty,
                strategy: currentStrategy,
                personality: currentPersonality,
                useLLMBanter: useLLMBanter
            });
            
            setTimeout(initializeCharts, 100); // Small delay to ensure DOM is ready
            setTimeout(() => {
                updateSelectedModelVisibility(); // Show only selected model by default
            }, 200);
            updateStatusDisplay();
            applyPersonalityTheme(currentPersonality);
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
            setTimeout(() => updateRobotConversation(currentPersonality, 'start'), 200);
            setupModeTabs();

            const resultElement = document.getElementById('result');
            if (resultElement) {
                defaultResultMessage = resultElement.textContent;
            }
            setGameLength();
            
            // Setup coaching interface
            const refreshCoachingBtn = document.getElementById('refresh-coaching-tips');
            if (refreshCoachingBtn) {
                refreshCoachingBtn.addEventListener('click', refreshCoachingTips);
            }
        });
        
        // Keyboard controls (removed duplicate listener)
        

        function highlightMatches() {
            if (!modelPredictionChart) return;
            const humanDataset = modelPredictionChart.data.datasets[0];
            const activeDatasets = modelPredictionChart.data.datasets
                .map((dataset, index) => ({ dataset, index }))
                .filter(({ dataset, index }) => index !== 0 && !dataset.hidden);

            modelPredictionChart.data.datasets.forEach((dataset, idx) => {
                if (idx === 0) {
                    dataset.pointBackgroundColor = dataset.data.map(() => '#FF6384');
                    dataset.pointRadius = dataset.data.map(() => 4);
                } else {
                    dataset.pointRadius = dataset.data.map(value => (dataset.hidden || value === null ? 0 : 3));
                    dataset.pointBackgroundColor = dataset.data.map(() => dataset.borderColor);
                }
            });

            if (activeDatasets.length === 1) {
                const { dataset: activeDataset } = activeDatasets[0];
                activeDataset.pointRadius = activeDataset.data.map((value, idx) => {
                    const humanValue = humanDataset.data[idx];  // Compare prediction to same index human move
                    return value !== null && value === humanValue ? 6 : 3;
                });
                activeDataset.pointBackgroundColor = activeDataset.data.map((value, idx) => {
                    const humanValue = humanDataset.data[idx];  // Compare prediction to same index human move
                    return value !== null && value === humanValue ? '#4ade80' : activeDataset.borderColor;
                });
            }
        }

        function initializeConfidenceToggle() {
            const toggleContainer = document.querySelector('.confidence-toggle');
            if (!toggleContainer) return;
            const inputs = toggleContainer.querySelectorAll('input[data-dataset-index]');

            inputs.forEach(input => {
                const idx = parseInt(input.dataset.datasetIndex, 10);
                if (!Number.isNaN(idx) && confidenceTrendChart && confidenceTrendChart.data.datasets[idx]) {
                    input.checked = !confidenceTrendChart.data.datasets[idx].hidden;
                }

                input.addEventListener('change', () => {
                    if (!confidenceTrendChart) return;
                    const index = parseInt(input.dataset.datasetIndex, 10);
                    if (Number.isNaN(index) || !confidenceTrendChart.data.datasets[index]) return;
                    confidenceTrendChart.data.datasets[index].hidden = !input.checked;
                    confidenceTrendChart.update();
                });
            });
        }

        function updateSelectedModelVisibility() {
            // Show only the selected model by default in confidence chart
            if (!confidenceTrendChart) return;
            
            const currentDifficulty = document.getElementById('difficulty').value;
            const difficultyToIndex = {
                'rookie': 0,
                'challenger': 1,
                'master': 2
            };
            
            const selectedIndex = difficultyToIndex[currentDifficulty];
            
            // Hide all datasets first
            confidenceTrendChart.data.datasets.forEach((dataset, idx) => {
                dataset.hidden = true;
            });
            
            // Show only the selected model
            if (selectedIndex !== undefined && confidenceTrendChart.data.datasets[selectedIndex]) {
                confidenceTrendChart.data.datasets[selectedIndex].hidden = false;
            }
            
            // Update checkbox states
            const toggleContainer = document.querySelector('.confidence-toggle');
            if (toggleContainer) {
                const inputs = toggleContainer.querySelectorAll('input[data-dataset-index]');
                inputs.forEach(input => {
                    const idx = parseInt(input.dataset.datasetIndex, 10);
                    input.checked = (idx === selectedIndex);
                });
            }
            
            confidenceTrendChart.update();
        }

        function initializePredictionToggle() {
            const toggleContainer = document.querySelector('.prediction-toggle');
            if (!toggleContainer) return;
            const inputs = toggleContainer.querySelectorAll('input[data-dataset-index]');
            const showAllToggle = document.getElementById('prediction-range-toggle');

            inputs.forEach(input => {
                const idx = parseInt(input.dataset.datasetIndex, 10);
                if (!Number.isNaN(idx) && modelPredictionChart && modelPredictionChart.data.datasets[idx]) {
                    input.checked = !modelPredictionChart.data.datasets[idx].hidden;
                }

                input.addEventListener('change', () => {
                    if (!modelPredictionChart) return;
                    const index = parseInt(input.dataset.datasetIndex, 10);
                    if (Number.isNaN(index) || !modelPredictionChart.data.datasets[index]) return;
                    modelPredictionChart.data.datasets[index].hidden = !input.checked;
                    highlightMatches();
                    modelPredictionChart.update();
                    
                    // Update debug panel to show currently selected model
                    if (lastChartData) {
                        updateDebugPanel(lastChartData);
                    }
                });
            });

            if (showAllToggle) {
                showAllToggle.checked = false;
                showAllToggle.addEventListener('change', () => {
                    if (lastChartData) {
                        const insights = deriveGameInsights(lastChartData);
                        updateOverviewPanel(insights);
                        updateCharts(lastChartData, insights);
                    }
                });
            }

            if (modelPredictionChart) {
                highlightMatches();
            }
        }

        function parseGameLimit(value) {
            return value === 'infinite' ? Infinity : parseInt(value, 10);
        }

        function setMoveButtonsDisabled(disabled) {
            document.querySelectorAll('.move-btn').forEach(btn => {
                btn.disabled = disabled;
                btn.classList.toggle('is-disabled', disabled);
            });
        }

        function setGameLength() {
            const select = document.getElementById('game-length');
            if (!select) return;
            currentGameLimit = parseGameLimit(select.value);
            if (!Number.isFinite(currentGameLimit)) {
                currentGameLimit = Infinity;
            }

            if (isGameFrozen && lastChartData && (lastChartData.round || 0) < currentGameLimit) {
                isGameFrozen = false;
                setMoveButtonsDisabled(false);
                const resultElement = document.getElementById('result');
                if (resultElement && defaultResultMessage) {
                    resultElement.textContent = defaultResultMessage;
                }
                const summaryPanel = document.getElementById('endgame-summary-panel');
                if (summaryPanel) {
                    summaryPanel.classList.remove('visible');
                    summaryPanel.innerHTML = '';
                }
                endgameSummaryShown = false;
            }

            if (lastChartData) {
                const insights = deriveGameInsights(lastChartData);
                updateOverviewPanel(insights);
                updateCharts(lastChartData, insights);
            }
        }

        function freezeGame(data, insights) {
            if (isGameFrozen) return;
            isGameFrozen = true;
            setMoveButtonsDisabled(true);
            renderPostGameSummary(insights);
            presentGameSummaryModal(insights);
        }

        function renderPostGameSummary(insights) {
            if (!insights) return;
            const resultElement = document.getElementById('result');
            if (!resultElement) return;
            const humanWins = insights.humanWins ?? 0;
            const robotWins = insights.robotWins ?? 0;
            const ties = insights.ties ?? 0;
            const overallWinRate = (insights.humanWinRate ?? 0).toFixed(1);
            const recentWinRate = (insights.recentHumanWinRate ?? 0).toFixed(1);
            const longestHumanStreak = insights.longestHumanStreak ?? 0;
            const longestRobotStreak = insights.longestRobotStreak ?? 0;
            const commonMove = insights.mostCommonMove ?? '‚Äî';
            const commonMovePct = (insights.mostCommonMovePercent ?? 0).toFixed(1);
            const recommendation = insights.recommendation || 'Keep experimenting with new patterns to maintain unpredictability.';
            const summaryLines = [
                `Final score: You ${humanWins} - Robot ${robotWins} (ties ${ties}).`,
                `Overall win rate: ${overallWinRate}% (last 10 rounds: ${recentWinRate}%).`,
                `Longest streaks ‚Äî You: ${longestHumanStreak} | Robot: ${longestRobotStreak}.`,
                `Most common move: ${commonMove} (${commonMovePct}%).`,
                recommendation
            ];
            resultElement.innerHTML = '<h3>Match Complete</h3><p>' + summaryLines.join('<br>') + '</p>';
        }

        function determineWinner(humanMove, robotMove) {
            if (!humanMove || !robotMove) return 'unknown';
            if (humanMove === robotMove) return 'tie';
            const normalizedHuman = humanMove.toLowerCase();
            const normalizedRobot = robotMove.toLowerCase();
            const winMap = { 'rock': 'scissors', 'scissors': 'paper', 'paper': 'rock' };
            return winMap[normalizedHuman] === normalizedRobot ? 'human' : 'robot';
        }

        function computeRollingAccuracy(predictions, actual) {
            const series = [];
            let considered = 0;
            let correct = 0;
            for (let i = 0; i < actual.length; i++) {
                const target = actual[i];
                const guess = predictions[i];
                if (target !== null && target !== undefined) {
                    if (guess !== null && guess !== undefined) {
                        considered += 1;
                        if (guess === target) correct += 1;
                    }
                }
                const value = considered > 0 ? (correct / considered) * 100 : 0;
                series.push(value);
            }
            return series;
        }

        function formatMoveName(move) {
            if (!move || move === 'unknown') return '‚Äî';
            const normalized = move.toLowerCase();
            if (normalized === 'rock') return 'Rock';
            if (normalized === 'scissors') return 'Scissors';
            return normalized.charAt(0).toUpperCase() + normalized.slice(1);
        }

        function deriveGameInsights(data) {
            // ===============================================
            // SINGLE SOURCE OF TRUTH: Backend Metrics Only
            // ===============================================
            // All metric calculations are now done in the backend (game_context.py)
            // Frontend only consumes and displays the pre-calculated metrics
            
            const metrics = data.metrics || {};
            const gameStatus = data.game_status || data;
            
            // Helper for current streak calculation (only UI-specific logic)
            const calculateCurrentStreak = (results) => {
                if (!results || results.length === 0) return { owner: 'tie', length: 0 };
                
                let currentStreakOwner = 'tie';
                let currentStreakLength = 0;
                for (let i = results.length - 1; i >= 0; i--) {
                    const w = results[i];
                    if (w === 'unknown' || w === 'tie') break;
                    if (currentStreakOwner === 'tie') {
                        currentStreakOwner = w;
                        currentStreakLength = 1;
                    } else if (w === currentStreakOwner) {
                        currentStreakLength += 1;
                    } else {
                        break;
                    }
                }
                return { owner: currentStreakOwner, length: currentStreakOwner === 'tie' ? 0 : currentStreakLength };
            };
            
            const currentStreak = calculateCurrentStreak(metrics.full_game_snapshot?.results);
            
            // Return insights object with ALL metrics from backend
            return {
                // Core metrics from backend unified calculation
                totalRounds: metrics.full_game_snapshot?.human_moves?.length || 0,
                humanWins: metrics.human_wins ?? 0,
                robotWins: metrics.robot_wins ?? 0,
                ties: metrics.ties ?? 0,
                humanWinRate: metrics.human_win_rate ?? 0,
                robotWinRate: metrics.robot_win_rate ?? 0,
                tieRate: metrics.tie_rate ?? 0,
                mostCommonMove: metrics.most_common_move ?? '‚Äî',
                mostCommonMovePercent: null, // Could be added to backend if needed
                
                // Advanced metrics from backend
                scoreDifferentialSeries: [metrics.score_differential ?? 0],
                recentHumanWinRate: metrics.recent_win_rate ?? 0,
                recentRobotWinRate: null, // Not currently calculated in backend
                recentBiasMove: metrics.recent_momentum?.recent_bias_type ?? '‚Äî',
                recentBiasPercent: metrics.recent_momentum?.recent_bias_percent ?? 0,
                longestHumanStreak: metrics.longest_human_streak ?? 0,
                longestRobotStreak: metrics.longest_robot_streak ?? 0,
                
                // UI-specific calculated fields
                currentStreakOwner: currentStreak.owner,
                currentStreakLength: currentStreak.length,
                
                // Backend predictability score (was moveVariance)
                moveVariance: metrics.predictability_score ?? 0,
                
                // AI metrics from backend
                aiConfidence: metrics.current_confidence_score ?? '--',
                aiAccuracy: null, // Could be derived if needed
                
                // Chart and visualization data (separate from core metrics)
                winners: metrics.full_game_snapshot?.results || [],
                accuracySeries: null, // Chart-specific, handled separately
                humanNumeric: null,   // Chart-specific, handled separately
                frequencyPreds: null, // Chart-specific, handled separately
                markovPreds: null,    // Chart-specific, handled separately
                lstmPreds: null,      // Chart-specific, handled separately
                
                // Static recommendation (could be moved to backend)
                recommendation: 'Keep monitoring patterns and adapt your strategy.',
            };
        }

        // Helper functions for Strategic Intelligence metrics
        function calculateMoveVariance(moveHistory) {
            if (!moveHistory || moveHistory.length < 3) return 0;
            
            const moveCounts = { paper: 0, rock: 0, scissors: 0 };
            moveHistory.forEach(move => {
                const normalized = move ? move.toLowerCase() : '';
                if (moveCounts.hasOwnProperty(normalized)) {
                    moveCounts[normalized]++;
                }
            });
            
            const total = moveHistory.length;
            const expectedFreq = total / 3; // Perfectly random would be 33.33% each
            const variance = Object.values(moveCounts).reduce((sum, count) => {
                return sum + Math.pow(count - expectedFreq, 2);
            }, 0) / 3;
            
            // Convert to 0-100 scale (higher = more predictable)
            return Math.min(100, (variance / expectedFreq) * 50);
        }

        function updateOverviewPanel(insights) {
            document.getElementById('overview-total-rounds').textContent = insights.totalRounds;
            document.getElementById('overview-human-winrate').textContent = insights.humanWinRate.toFixed(1) + '%';
            document.getElementById('overview-robot-winrate').textContent = insights.robotWinRate.toFixed(1) + '%';
            document.getElementById('overview-tie-rate').textContent = insights.tieRate.toFixed(1) + '%';
            document.getElementById('overview-longest-human').textContent = insights.longestHumanStreak || 0;
            document.getElementById('overview-longest-robot').textContent = insights.longestRobotStreak || 0;
            document.getElementById('overview-common-move').textContent = insights.mostCommonMove;
            document.getElementById('overview-recent-winrate').textContent = insights.recentHumanWinRate.toFixed(1) + '%';
            const streakLabel = insights.currentStreakLength > 0 ? ((insights.currentStreakOwner === 'human' ? 'Your ' : 'Robot ') + insights.currentStreakLength + ' streak') : 'No streak';
            document.getElementById('overview-current-streak').textContent = streakLabel;
            document.getElementById('overview-recent-move').textContent = insights.recentBiasMove !== '‚Äî' ? insights.recentBiasMove + ' (' + insights.recentBiasPercent.toFixed(1) + '%)' : '‚Äî';
            const scoreDiff = insights.humanWins - insights.robotWins;
            document.getElementById('overview-score-diff').textContent = scoreDiff;
            
            // New metrics for Strategic Intelligence
            // document.getElementById('overview-ai-accuracy') removed as requested
            document.getElementById('overview-ai-confidence').textContent = insights.aiConfidence + '%';
            
            // Calculate predictability (higher moveVariance = more predictable)
            const predictabilityScore = insights.moveVariance || 33.3;
            document.getElementById('overview-predictability').textContent = predictabilityScore.toFixed(1) + '%';
            
            document.getElementById('overview-recommendation').textContent = insights.recommendation;
        }



        function setupModeTabs() {
            const switchers = document.querySelectorAll('.mode-switcher');
            switchers.forEach(switcher => {
                const tabs = switcher.querySelectorAll('.mode-tab');
                const panelsContainer = switcher.nextElementSibling && switcher.nextElementSibling.classList.contains('mode-panels')
                    ? switcher.nextElementSibling
                    : null;

                if (!tabs.length || !panelsContainer) return;

                const panels = panelsContainer.querySelectorAll('.mode-panel');
                if (!panels.length) return;

                const activateMode = (mode) => {
                    tabs.forEach(tab => {
                        const isActive = tab.dataset.mode === mode;
                        tab.classList.toggle('active', isActive);
                        tab.setAttribute('aria-pressed', isActive);
                    });
                    panels.forEach(panel => {
                        panel.classList.toggle('active', panel.dataset.mode === mode);
                    });
                };

                tabs.forEach(tab => {
                    tab.addEventListener('click', () => activateMode(tab.dataset.mode));
                });

                const initialTab = switcher.querySelector('.mode-tab.active') || tabs[0];
                if (initialTab) activateMode(initialTab.dataset.mode);
            });
        }

        // Game functions
        function submitMove(move) {
            if (isGameFrozen) return;
            console.log('submitMove called with:', move);
            
            // Reset the battle arena for new round
            resetMoveDisplay();
            
            const payload = {
                move: move,
                difficulty: currentDifficulty,
                strategy: currentStrategy,
                personality: currentPersonality,
                game_limit: Number.isFinite(currentGameLimit) ? currentGameLimit : null
            };
            
            console.log('Sending payload:', payload);
            
            fetch('/play', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            })
            .then(res => {
                console.log('Response status:', res.status);
                return res.json();
            })
            .then(data => {
                console.log('Received data:', data);
                updateUI(data);
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('result').innerHTML = 
                    '<p style="color: red;">Error: ' + error.message + '</p>';
            });
        }
        
        function updateUI(data) {
            if (isGameFrozen) return;
            console.log('Updating UI with:', data);

            // Safely get the last human move
            const lastHumanMove = data.human_history && data.human_history.length > 0 
                ? data.human_history[data.human_history.length-1] 
                : 'unknown';

            // Safely get the robot move
            const robotMove = data.robot_move || 'unknown';

            // Safely get the result
            const result = data.result ? String(data.result) : 'unknown';

            const insights = deriveGameInsights(data);

            // Update result
            document.getElementById('result').innerHTML = 
                '<h3>Round ' + (data.round || 0) + ' Results</h3>' +
                '<p>You played: <strong>' + lastHumanMove.toUpperCase() + '</strong></p>' +
                '<p>Computer played: <strong>' + robotMove.toUpperCase() + '</strong></p>' +
                '<p>Result: <strong>' + result.toUpperCase() + '</strong></p>';
            
            // Update stats safely
            const stats = data.stats || {};
            document.getElementById('rounds').textContent = data.round || 0;
            document.getElementById('human-wins').textContent = stats.human_win || 0;
            document.getElementById('robot-wins').textContent = stats.robot_win || 0;
            document.getElementById('ties').textContent = stats.tie || 0;
            
            // Update strategy display
            if (data.current_strategy) {
                const strategy = String(data.current_strategy);
                document.getElementById('current-strategy-text').textContent = 
                    strategy.charAt(0).toUpperCase() + strategy.slice(1);
            }
            
            // Note: Auto-refresh coaching tips removed with Coach View cleanup

            // Update analytics dashboard
            updateAnalyticsDashboard(data, insights);

            // Update charts
            updateCharts(data);

            // Check if game should end based on game length limit
            if (Number.isFinite(currentGameLimit) && data.round >= currentGameLimit) {
                // Ensure all UI updates are complete before freezing
                // Use longer delay to guarantee metrics are displayed
                setTimeout(() => {
                    // Recalculate insights with final data to ensure accuracy
                    const finalInsights = deriveGameInsights(data);
                    freezeGame(data, finalInsights);
                }, 10); // Increased delay to ensure all updates are rendered
            }
            
            // Update move display window
            updateMoveDisplay(lastHumanMove, robotMove, result);
            
            // Update live alert rail
            updateAlertRail(data, result);

            // Update robot conversation based on result
            const conversationEventType = result === 'human' ? 'lose' : result === 'robot' ? 'win' : 'tie';
            setTimeout(() => {
                updateRobotConversation(currentPersonality, conversationEventType, {
                    humanMove: lastHumanMove,
                    robotMove: robotMove,
                    round: data.round,
                    humanWinRate: insights?.humanWinRate,
                    robotWinRate: insights?.robotWinRate,
                    totalRounds: insights?.totalRounds
                });
                
                // Update coaching stats if in coach view
                if (insights?.totalRounds >= 5) {
                    updateCoachingStats({
                        human_moves: data.human_history || [],
                        robot_moves: data.robot_history || [],
                        results: data.result_history || [],
                        round: insights.totalRounds
                    });
                }
            }, 800); // Delay to let move display finish
        }
        
        // Move Display Window Functions
        function updateMoveDisplay(humanMove, robotMove, result) {
            // Update human move
            updatePlayerMove('human', humanMove);
            
            // Update robot move with a shorter delay for faster loading
            setTimeout(() => {
                updatePlayerMove('robot', robotMove);
                // Show result immediately after robot move is displayed
                setTimeout(() => {
                    showRoundResult(result, humanMove, robotMove);
                }, 150);
            }, 200);
        }
        
        function updatePlayerMove(player, move) {
            const moveImg = document.getElementById(player + '-move-img');
            const moveText = document.getElementById(player + '-move-text');
            
            if (move && move !== 'unknown') {
                // Set the correct image
                const imageMap = {
                    'rock': '/static/rock.png',    // Note: keeping image filename as stone.png
                    'paper': '/static/paper.png',
                    'scissors': '/static/scissors.png' // Note: keeping image filename as scissor.png
                };
                
                moveImg.src = imageMap[move.toLowerCase()] || '/static/paper.png';
                moveImg.style.display = 'block';
                moveText.textContent = move.charAt(0).toUpperCase() + move.slice(1);
            } else {
                moveImg.style.display = 'none';
                moveText.textContent = player === 'human' ? 'Choose your move' : 'Thinking...';
            }
        }
        
        function showRoundResult(result, humanMove, robotMove) {
            const resultDiv = document.getElementById('round-result');
            const humanDisplay = document.getElementById('human-move-display');
            const robotDisplay = document.getElementById('robot-move-display');
            
            // Reset borders
            humanDisplay.style.border = '2px solid transparent';
            robotDisplay.style.border = '2px solid transparent';
            
            // Show result and highlight winner
            if (result === 'human') {
                resultDiv.textContent = 'üéâ You Win!';
                resultDiv.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
                resultDiv.style.color = 'white';
                humanDisplay.style.border = '2px solid #28a745';
                humanDisplay.style.boxShadow = '0 0 15px rgba(40, 167, 69, 0.4)';
            } else if (result === 'robot') {
                resultDiv.textContent = 'ü§ñ Robot Wins!';
                resultDiv.style.background = 'linear-gradient(135deg, #dc3545, #e83e8c)';
                resultDiv.style.color = 'white';
                robotDisplay.style.border = '2px solid #dc3545';
                robotDisplay.style.boxShadow = '0 0 15px rgba(220, 53, 69, 0.4)';
            } else {
                resultDiv.textContent = 'ü§ù It\'s a Tie!';
                resultDiv.style.background = 'linear-gradient(135deg, #ffc107, #fd7e14)';
                resultDiv.style.color = 'white';
                humanDisplay.style.border = '2px solid #ffc107';
                robotDisplay.style.border = '2px solid #ffc107';
            }
            
            resultDiv.style.display = 'block';
            
            // Don't auto-reset - keep result until next move
        }
        
        function resetMoveDisplay() {
            // Hide images and reset text
            document.getElementById('human-move-img').style.display = 'none';
            document.getElementById('robot-move-img').style.display = 'none';
            document.getElementById('human-move-text').textContent = 'Choose your move';
            document.getElementById('robot-move-text').textContent = 'Thinking...';
            document.getElementById('round-result').style.display = 'none';
            
            // Reset borders and shadows
            const humanDisplay = document.getElementById('human-move-display');
            const robotDisplay = document.getElementById('robot-move-display');
            humanDisplay.style.border = '2px solid transparent';
            robotDisplay.style.border = '2px solid transparent';
            humanDisplay.style.boxShadow = 'none';
            robotDisplay.style.boxShadow = 'none';
        }
        
        // Robot Character Visualization Functions
        function updateRobotCharacter(difficulty, strategy, personality) {
            console.log('updateRobotCharacter called with:', difficulty, strategy, personality);
            updateRobotAvatar(difficulty, personality);
            updateStrategySymbol(strategy);
            updateRobotInfo(difficulty, strategy, personality);
        }
        
        function updateRobotAvatar(difficulty, personality) {
            const avatar = document.getElementById('robot-avatar');
            console.log('updateRobotAvatar - element found:', avatar, 'difficulty:', difficulty, 'personality:', personality);
            
            if (!avatar) {
                console.error('robot-avatar element not found!');
                return;
            }
            
            // Personality character mapping
            const personalityChars = {
                'neutral': 'ü§ñ',
                'aggressive': '‚öîÔ∏è',
                'defensive': 'üõ°Ô∏è', 
                'unpredictable': 'üé≤',
                'cautious': 'üîç',
                'confident': 'üí™',
                'chameleon': 'ÔøΩ',
                'balanced': 'ü§ñ'
            };
            
            // Difficulty-based background shading
            const difficultyStyles = {
                'rookie': {
                    background: 'linear-gradient(135deg, #e8f5e8, #d4edda)',
                    border: '3px solid #28a745'
                },
                'challenger': {
                    background: 'linear-gradient(135deg, #fff3cd, #ffeaa7)',
                    border: '3px solid #ffc107'
                },
                'master': {
                    background: 'linear-gradient(135deg, #f8d7da, #f5b7b1)',
                    border: '3px solid #dc3545'
                }
            };
            
            // Update character
            const char = personalityChars[personality] || 'ü§ñ';
            console.log('Setting avatar char:', char);
            avatar.textContent = char;
            
            // Update styling
            const style = difficultyStyles[difficulty] || difficultyStyles['rookie'];
            console.log('Setting avatar style:', style);
            avatar.style.background = style.background;
            avatar.style.border = style.border;
        }
        
        function updateStrategySymbol(strategy) {
            const symbolElement = document.getElementById('strategy-symbol');
            console.log('updateStrategySymbol - element found:', symbolElement, 'strategy:', strategy);
            
            if (!symbolElement) {
                console.error('strategy-symbol element not found!');
                return;
            }
            
            // Strategy/Difficulty symbol mapping
            const strategySymbols = {
                // New difficulty levels
                'rookie': 'ÔøΩ',
                'challenger': 'ÔøΩ', 
                'master': 'üî¥',
                // Strategy types
                'pattern': 'üîÑ',
                'balanced': '‚öñÔ∏è',
                'to_win': '‚öîÔ∏è',
                'not_to_lose': 'üõ°Ô∏è',
                // Legacy support
                'random': 'üé≤',
                'frequency': 'üìä',
                'markov': 'üß†',
                'minimax': '‚öîÔ∏è',
                'lstm': 'ü§ñ'
            };
            
            const symbol = strategySymbols[strategy] || '‚öîÔ∏è';
            console.log('Setting symbol to:', symbol);
            symbolElement.textContent = symbol;
        }
        
        function updateRobotInfo(difficulty, strategy, personality) {
            console.log('updateRobotInfo called with:', difficulty, strategy, personality);
            
            // Generate robot name based on personality and difficulty
            const names = {
                'neutral': ['Standard', 'Basic', 'Default', 'Unit'],
                'aggressive': ['Destroyer', 'Annihilator', 'Crusher', 'Devastator'],
                'defensive': ['Protector', 'Defender', 'Shield', 'Bulwark'],
                'unpredictable': ['Chaos', 'Random', 'Surprise', 'Wildfire'],
                'cautious': ['Analyst', 'Scholar', 'Calculator', 'Logic'],
                'confident': ['Echo', 'Reflection', 'Shadow', 'Copy'],
                'chameleon': ['Shifter', 'Adapter', 'Morph', 'Mimic'],
                // Legacy support
                'berserker': ['Destroyer', 'Annihilator', 'Crusher', 'Devastator'],
                'guardian': ['Protector', 'Defender', 'Shield', 'Bulwark'],
                'professor': ['Analyst', 'Scholar', 'Calculator', 'Logic'],
                'wildcard': ['Chaos', 'Random', 'Surprise', 'Wildfire'],
                'mirror': ['Echo', 'Reflection', 'Shadow', 'Copy'],
                'balanced': ['Standard', 'Basic', 'Default', 'Unit']
            };
            
            const nameList = names[personality] || names['neutral'];
            const baseName = nameList[Math.floor(Math.random() * nameList.length)];
            const difficultyPrefix = {
                // New 42-opponent difficulties
                'rookie': 'Basic',
                'challenger': 'Advanced', 
                'master': 'Legendary',
                // Legacy support for charts/compatibility
                'random': 'Basic',
                'frequency': 'Junior', 
                'markov': 'Advanced',
                'lstm': 'Legendary'
            };
            
            const difficultyNames = {
                // New 42-opponent difficulties
                'rookie': 'Rookie',
                'challenger': 'Challenger',
                'master': 'Master',
                // Legacy support for charts/compatibility
                'random': 'Random',
                'frequency': 'Frequency Analysis',
                'markov': 'Markov Chain',
                'lstm': 'LSTM Neural Network'
            };
            
            const strategyNames = {
                'balanced': 'Balanced',
                'to_win': 'Aggressive (To Win)',
                'not_to_lose': 'Defensive (Not to Lose)'
            };
            
            const personalityNames = {
                // New 42-opponent personalities
                'neutral': 'Neutral',
                'aggressive': 'The Destroyer',
                'defensive': 'The Guardian',
                'unpredictable': 'The Wildcard',
                'cautious': 'The Scholar',
                'confident': 'The Mirror',
                'chameleon': 'The Chameleon',
                // Legacy support
                'berserker': 'The Berserker',
                'guardian': 'The Guardian',
                'professor': 'The Professor',
                'wildcard': 'The Wildcard',
                'mirror': 'The Mirror'
            };
            
            const robotName = `${difficultyPrefix[difficulty] || 'Basic'} ${baseName}`;
            
            console.log('Updating robot display with:', {
                robotName,
                difficulty: difficultyNames[difficulty] || difficulty,
                strategy: strategyNames[strategy] || strategy,
                personality: personalityNames[personality] || personality
            });
            
            // Update display with proper names
            const robotNameElement = document.getElementById('robot-name');
            const robotDifficultyElement = document.getElementById('robot-difficulty');
            const robotStrategyElement = document.getElementById('robot-strategy');
            const robotPersonalityElement = document.getElementById('robot-personality');
            
            if (robotNameElement) robotNameElement.textContent = robotName;
            if (robotDifficultyElement) robotDifficultyElement.textContent = difficultyNames[difficulty] || difficulty;
            if (robotStrategyElement) robotStrategyElement.textContent = strategyNames[strategy] || strategy;
            if (robotPersonalityElement) robotPersonalityElement.textContent = personalityNames[personality] || personality;
            
            console.log('Robot info updated successfully');
        }
        
        // Robot Conversation System Functions
        function updateRobotConversation(personality, eventType, data = {}) {
            const speechElement = document.getElementById('robot-speech');
            const moodElement = document.getElementById('robot-mood');
            const avatarElement = document.getElementById('conversation-avatar');
            const calloutElement = document.getElementById('player-performance-callout');

            // Check if user wants LLM-generated banter or rule-based
            if (useLLMBanter) {
                // Use SBC Backend for dynamic LLM-generated banter
                generateSBCBanter(personality, eventType, data).then(dialogue => {
                    // Update speech by printing text directly
                    speechElement.textContent = dialogue.message;

                    // Update mood and avatar
                    moodElement.textContent = dialogue.mood;
                    avatarElement.textContent = dialogue.avatar;
                }).catch(error => {
                    console.warn('SBC Backend unavailable, using fallback dialogue:', error);
                    // Fallback to rule-based dialogue when LLM fails
                    const dialogue = generatePersonalityDialogue(personality, eventType, data);
                    speechElement.textContent = dialogue.message;
                    moodElement.textContent = dialogue.mood;
                    avatarElement.textContent = dialogue.avatar;
                });
            } else {
                // Use rule-based personality dialogue (default)
                const dialogue = generatePersonalityDialogue(personality, eventType, data);
                speechElement.textContent = dialogue.message;
                moodElement.textContent = dialogue.mood;
                avatarElement.textContent = dialogue.avatar;
            }

            if (calloutElement) {
                const humanWinRate = typeof data.humanWinRate === 'number' ? data.humanWinRate : null;
                const robotWinRate = typeof data.robotWinRate === 'number' ? data.robotWinRate : null;
                const totalRounds = typeof data.totalRounds === 'number' ? data.totalRounds : 0;

                if (humanWinRate !== null && robotWinRate !== null && totalRounds > 0) {
                    if (humanWinRate > robotWinRate + 0.5) {
                        calloutElement.textContent = `üî• You're ahead with a ${humanWinRate.toFixed(1)}% win rate!`;
                        calloutElement.classList.add('visible');
                    } else if (robotWinRate > humanWinRate + 0.5) {
                        calloutElement.textContent = `‚ö†Ô∏è AI is leading at ${robotWinRate.toFixed(1)}% ‚Äî time to adjust!`;
                        calloutElement.classList.add('visible');
                    } else {
                        calloutElement.textContent = `ü§ù It's a tight contest: ${humanWinRate.toFixed(1)}% vs ${robotWinRate.toFixed(1)}%.`;
                        calloutElement.classList.add('visible');
                    }
                } else {
                    calloutElement.classList.remove('visible');
                    calloutElement.textContent = '';
                }
            }
        }
        
        async function generateSBCBanter(personality, eventType, data) {
            try {
                const response = await fetch('/sbc/banter', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        personality: personality,
                        eventType: eventType,
                        data: data
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const result = await response.json();
                
                // Map to expected format
                return {
                    message: result.banter,
                    mood: getPersonalityMood(personality, eventType),
                    avatar: getPersonalityAvatar(personality)
                };
            } catch (error) {
                console.error('SBC Backend error:', error);
                throw error;
            }
        }
        
        function getPersonalityMood(personality, eventType) {
            const moodMap = {
                'berserker': {
                    'start': 'üíÄ Bloodthirsty',
                    'win': 'üëπ Triumphant', 
                    'lose': 'üò° Furious',
                    'tie': 'üò§ Frustrated',
                    'default': 'üíÄ Aggressive'
                },
                'guardian': {
                    'start': 'üõ°Ô∏è Watchful',
                    'win': 'üòå Satisfied',
                    'lose': 'ü§î Analyzing',
                    'tie': '‚öñÔ∏è Balanced',
                    'default': 'üõ°Ô∏è Defensive'
                },
                'chameleon': {
                    'start': 'ü¶é Adaptive',
                    'win': 'üòä Pleased',
                    'lose': 'ü§î Learning',
                    'tie': 'üîÑ Adjusting',
                    'default': 'ü¶é Flexible'
                },
                'professor': {
                    'start': 'üß† Analytical',
                    'win': 'üòä Satisfied',
                    'lose': 'ü§î Analyzing',
                    'tie': '‚öñÔ∏è Balanced',
                    'default': 'üß† Thoughtful'
                },
                'wildcard': {
                    'start': 'üé≤ Chaotic',
                    'win': 'ü§™ Ecstatic',
                    'lose': 'üòú Amused',
                    'tie': 'üé≠ Unpredictable',
                    'default': 'üé≤ Random'
                },
                'mirror': {
                    'start': 'ü™û Observing',
                    'win': 'üòä Mirroring',
                    'lose': 'ü§î Adapting',
                    'tie': 'üîÑ Reflecting',
                    'default': 'ü™û Reflective'
                },
                'neutral': {
                    'start': 'üòê Neutral',
                    'win': 'üòä Happy',
                    'lose': 'üòï Disappointed',
                    'tie': 'üòê Neutral',
                    'default': 'üòê Calm'
                }
            };
            
            const personalityMoods = moodMap[personality] || moodMap['neutral'];
            return personalityMoods[eventType] || personalityMoods['default'];
        }
        
        function getPersonalityAvatar(personality) {
            const avatarMap = {
                'berserker': 'üíÄ',
                'guardian': 'üõ°Ô∏è',
                'chameleon': 'ü¶é',
                'professor': 'üß†',
                'wildcard': 'üé≤',
                'mirror': 'ü™û',
                'neutral': 'üòê'
            };
            
            return avatarMap[personality] || 'üòê';
        }
        
        function generateFallbackDialogue(personality, eventType, data) {
            // Simple fallback dialogue for when SBC Backend is unavailable
            const fallbackMessages = {
                'berserker': { start: "Let's battle!", win: "Victory!", lose: "Defeat...", tie: "Draw!" },
                'guardian': { start: "Defense ready!", win: "Success!", lose: "Good game!", tie: "Even!" },
                'chameleon': { start: "Adapting...", win: "Evolved!", lose: "Learning!", tie: "Balanced!" },
                'professor': { start: "Analyzing...", win: "Calculated!", lose: "Interesting!", tie: "Logical!" },
                'wildcard': { start: "Random mode!", win: "Chaos wins!", lose: "Randomness!", tie: "Chaotic!" },
                'mirror': { start: "Observing...", win: "Reflected!", lose: "Mirrored!", tie: "Symmetric!" },
                'neutral': { start: "Starting...", win: "Won!", lose: "Lost!", tie: "Tied!" }
            };
            
            const messages = fallbackMessages[personality] || fallbackMessages['neutral'];
            return {
                message: messages[eventType] || messages['start'],
                mood: getPersonalityMood(personality, eventType),
                avatar: getPersonalityAvatar(personality)
            };
        }
        
        function generatePersonalityDialogue(personality, eventType, data) {
            const dialogues = {
                'berserker': {
                    'start': {
                        messages: ["CRUSH YOUR ENEMIES!", "No mercy! Let's fight!", "I will dominate this battle!", "Prepare for destruction!"],
                        mood: "üíÄ Bloodthirsty",
                        avatar: "üíÄ"
                    },
                    'win': {
                        messages: ["VICTORY IS MINE!", "Another victim falls!", "Bow before my might!", "Total annihilation!"],
                        mood: "üëπ Triumphant",
                        avatar: "üëπ"
                    },
                    'lose': {
                        messages: ["IMPOSSIBLE! I demand a rematch!", "This rage fuels my power!", "You got lucky this time!", "I will have my revenge!"],
                        mood: "üò° Furious",
                        avatar: "üò°"
                    },
                    'tie': {
                        messages: ["We're equally matched!", "The battle continues!", "Neither yields!", "This proves nothing!"],
                        mood: "‚öîÔ∏è Intense",
                        avatar: "‚öîÔ∏è"
                    }
                },
                'guardian': {
                    'start': {
                        messages: ["I shall protect my honor!", "Defense is the best strategy!", "Stand firm and endure!", "My shield is unbreakable!"],
                        mood: "üõ°Ô∏è Steadfast",
                        avatar: "üõ°Ô∏è"
                    },
                    'win': {
                        messages: ["A well-defended victory!", "Patience and defense prevail!", "Honor is preserved!", "The shield holds strong!"],
                        mood: "üèÜ Honorable",
                        avatar: "üèÜ"
                    },
                    'lose': {
                        messages: ["I fought with honor!", "Sometimes the shield fails...", "Your strategy was admirable!", "I must strengthen my defense!"],
                        mood: "üí™ Resolute",
                        avatar: "üí™"
                    },
                    'tie': {
                        messages: ["A noble stalemate!", "Both warriors show courage!", "Evenly matched defenses!", "Honor to both sides!"],
                        mood: "ü§ù Respectful",
                        avatar: "ü§ù"
                    }
                },
                'chameleon': {
                    'start': {
                        messages: ["Adapting to your style...", "Let me observe your patterns!", "I'll match your energy!", "Time to blend strategies!"],
                        mood: "ü¶é Adaptive",
                        avatar: "ü¶é"
                    },
                    'win': {
                        messages: ["Perfect adaptation!", "I mirrored your weakness!", "Flexibility wins again!", "Change is my strength!"],
                        mood: "üéØ Precise",
                        avatar: "üéØ"
                    },
                    'lose': {
                        messages: ["Interesting... recalibrating!", "Your unpredictability impressed me!", "Time to adapt further!", "Learning from this defeat!"],
                        mood: "üîÑ Evolving",
                        avatar: "üîÑ"
                    },
                    'tie': {
                        messages: ["We adapted to each other!", "Perfectly balanced strategies!", "Mutual adaptation!", "Synchronized thinking!"],
                        mood: "‚öñÔ∏è Balanced",
                        avatar: "‚öñÔ∏è"
                    }
                },
                'professor': {
                    'start': {
                        messages: ["Let's analyze this scientifically!", "Fascinating tactical possibilities!", "Time for logical deduction!", "The data suggests..."],
                        mood: "üî¨ Analytical",
                        avatar: "üéì"
                    },
                    'win': {
                        messages: ["Hypothesis confirmed!", "The calculations were correct!", "Logic prevails once again!", "A predictable outcome!"],
                        mood: "üß† Satisfied",
                        avatar: "üß†"
                    },
                    'lose': {
                        messages: ["Intriguing! An anomaly to study!", "Unexpected variables detected!", "This requires further analysis!", "Statistical outlier noted!"],
                        mood: "ü§î Curious",
                        avatar: "ü§î"
                    },
                    'tie': {
                        messages: ["Statistically balanced outcome!", "Equilibrium achieved!", "Perfect probability distribution!", "Fascinating data point!"],
                        mood: "üìä Logical",
                        avatar: "üìä"
                    }
                },
                'wildcard': {
                    'start': {
                        messages: ["Chaos time! Expect anything!", "Rules? What rules?!", "Let's shake things up!", "Random madness incoming!"],
                        mood: "üÉè Chaotic",
                        avatar: "üÉè"
                    },
                    'win': {
                        messages: ["BOOM! Didn't see that coming!", "Chaos reigns supreme!", "Random victory dance!", "Unpredictability wins!"],
                        mood: "üéâ Ecstatic",
                        avatar: "üéâ"
                    },
                    'lose': {
                        messages: ["Whoops! That was unexpected!", "Plot twist! You got me!", "Chaos works both ways!", "Random defeat... or is it?"],
                        mood: "ü§™ Amused",
                        avatar: "ü§™"
                    },
                    'tie': {
                        messages: ["What are the odds?!", "Chaos creates balance!", "Perfectly random outcome!", "Even randomness has patterns!"],
                        mood: "üé≤ Surprised",
                        avatar: "üé≤"
                    }
                },
                'mirror': {
                    'start': {
                        messages: ["I reflect your every move!", "Mirror mirror on the wall...", "Your style becomes mine!", "Copying... initializing..."],
                        mood: "ü™û Mirroring",
                        avatar: "ü™û"
                    },
                    'win': {
                        messages: ["I became you, but better!", "Perfect reflection achieved!", "Your own moves defeated you!", "Mirror mastery complete!"],
                        mood: "‚ú® Reflected",
                        avatar: "‚ú®"
                    },
                    'lose': {
                        messages: ["You broke the mirror!", "Reflection incomplete...", "My copy wasn't perfect!", "Time to re-calibrate reflection!"],
                        mood: "üí´ Fragmented",
                        avatar: "üí´"
                    },
                    'tie': {
                        messages: ["Perfect mirror match!", "Two reflections collide!", "We are the same!", "Mirror meets mirror!"],
                        mood: "üîÑ Synchronized",
                        avatar: "üîÑ"
                    }
                },
                'neutral': {
                    'start': {
                        messages: ["Ready for battle? Let's play!", "I'll analyze your patterns.", "May the best strategy win!", "Game on!"],
                        mood: "ü§ñ Ready",
                        avatar: "ü§ñ"
                    },
                    'win': {
                        messages: ["Good game! I predicted correctly.", "My analysis paid off!", "Strategy successful!", "Well played!"],
                        mood: "üòä Satisfied",
                        avatar: "üòä"
                    },
                    'lose': {
                        messages: ["Nice move! You got me there.", "Impressive strategy!", "I'll adapt for next time.", "You outplayed me!"],
                        mood: "ü§î Analyzing",
                        avatar: "ü§î"
                    },
                    'tie': {
                        messages: ["Great minds think alike!", "Even match!", "Balanced strategies!", "Perfect tie!"],
                        mood: "‚öñÔ∏è Balanced",
                        avatar: "‚öñÔ∏è"
                    }
                }
            };
            
            const personalityData = dialogues[personality] || dialogues['neutral'] || dialogues['berserker'];
            const eventData = personalityData[eventType] || personalityData['start'];
            
            return {
                message: eventData.messages[Math.floor(Math.random() * eventData.messages.length)],
                mood: eventData.mood,
                avatar: eventData.avatar
            };
        }
        
        function typeMessage(element, message) {
            element.textContent = '';
            let i = 0;
            const typingSpeed = 30; // ms per character
            
            function typeChar() {
                if (i < message.length) {
                    element.textContent += message.charAt(i);
                    i++;
                    setTimeout(typeChar, typingSpeed);
                }
            }
            
            typeChar();
        }
        
        // Advanced Analytics Functions
        function updateAlertRail(data, roundResult) {
            const alertContainer = document.getElementById('alert-feed');
            if (!alertContainer) return;

            const alerts = [];

            if (data && data.round) {
                alerts.push({ type: 'info', message: `Round ${data.round} complete` });
            }

            if (roundResult === 'human') {
                alerts.push({ type: 'positive', message: 'You claimed the last round ‚Äî keep the momentum!' });
            } else if (roundResult === 'robot') {
                alerts.push({ type: 'warning', message: 'The AI won the last exchange. Consider shifting patterns.' });
            } else if (roundResult === 'tie') {
                alerts.push({ type: 'info', message: 'Tie round ‚Äî a clean slate to pivot your strategy.' });
            }

            if (data && data.current_strategy) {
                const strategyLabels = {
                    'random': 'Random Baseline',
                    'frequency': 'Frequency Counter',
                    'markov': 'Markov Predictor',
                    'lstm': 'LSTM Neural'
                };
                const label = strategyLabels[data.current_strategy] || data.current_strategy;
                alerts.push({ type: 'info', message: `AI strategy focus: ${label}` });
            }

            if (data && Array.isArray(data.human_history) && data.human_history.length) {
                const history = data.human_history;
                const tally = history.reduce((acc, move) => {
                    if (move) acc[move] = (acc[move] || 0) + 1;
                    return acc;
                }, {});

                const moves = Object.keys(tally);
                if (moves.length) {
                    const total = history.length;
                    const dominant = moves.reduce((a, b) => (tally[a] || 0) >= (tally[b] || 0) ? a : b);
                    const dominantPercent = ((tally[dominant] / total) * 100).toFixed(1);

                    if (dominantPercent >= 60) {
                        const label = dominant.charAt(0).toUpperCase() + dominant.slice(1);
                        alerts.push({ type: 'warning', message: `Pattern emerging: ${label} showing ${dominantPercent}% usage.` });
                        alerts.push({ type: 'action', message: 'Hop into Pattern View to disrupt the streak.' });
                    }

                    const recent = history.slice(-3);
                    if (recent.length === 3 && new Set(recent).size === 1) {
                        const streakMove = recent[0];
                        const label = streakMove.charAt(0).toUpperCase() + streakMove.slice(1);
                        alerts.push({ type: 'warning', message: `Three-in-a-row streak detected (${label}).` });
                    }
                }
            }

            if (!alerts.length) {
                alertContainer.innerHTML = "<div class='alert-chip muted'>Play a round to populate insights.</div>";
                return;
            }

            const badgeClass = (type) => {
                if (type === 'positive') return 'positive';
                if (type === 'warning') return 'warning';
                if (type === 'action') return 'action';
                return 'info';
            };

            alertContainer.innerHTML = alerts
                .map(alert => `<div class="alert-chip ${badgeClass(alert.type)}">${alert.message}</div>`)
                .join('');
        }

        function updateAnalyticsDashboard(data, insights) {
            if (isGameFrozen) return;
            if (!data.human_history || data.human_history.length === 0) return;

            // Always calculate and update insights first, even for final round
            insights = insights || deriveGameInsights(data);

            // Update the overview panel with the latest insights (including final round)
            updateOverviewPanel(insights);

            // Note: Pattern View specific updates have been removed
            // All pattern analysis elements were removed with the Pattern View cleanup

            // Note: Pattern View specific updates have been removed
            // All pattern analysis elements were removed with the Pattern View cleanup
        }
        
        function refreshAnalytics() {
            console.log('Refreshing analytics...');
            fetch('/history')
            .then(res => res.json())
            .then(data => {
                console.log('Analytics data received:', data);
                const insights = deriveGameInsights(data);
                updateOverviewPanel(insights);
                updateAnalyticsDashboard(data, insights);
                updateCharts(data);
            })
            .catch(err => console.log('Analytics refresh failed:', err));
        }
        
        function presentGameSummaryModal(payload) {
            if (endgameSummaryShown) return;
            endgameSummaryShown = true;

            const panel = document.getElementById('endgame-summary-panel');
            if (!panel) return;

            const insights = (payload && payload.human_history) ? deriveGameInsights(payload) : payload;
            const gameData = (payload && payload.human_history) ? payload : null;
            const roundsPlayed = gameData ? gameData.round : (payload?.round ?? 0);
            const matchLength = Number.isFinite(currentGameLimit) ? `${currentGameLimit} moves` : `${roundsPlayed} moves`;
            const humanWins = insights?.humanWins ?? 0;
            const robotWins = insights?.robotWins ?? 0;
            const winnerMessage = humanWins === robotWins
                ? 'ü§ù It ends in a draw ‚Äî closely matched strategies.'
                : humanWins > robotWins
                    ? 'üèÜ Winner: You outplayed the AI this round!'
                    : 'ü§ñ Winner: The AI claimed this match. Time to regroup!';

            panel.innerHTML = `
                <h2>üèÅ Game Complete</h2>
                <p class="summary-subtitle">Session summary after ${matchLength}</p>
                <div class="summary-winner">${winnerMessage}</div>
                <div class="summary-grid">
                    <div class="summary-card">
                        <div class="summary-value">${(insights?.humanWinRate ?? 0).toFixed(1)}%</div>
                        <div class="summary-label">Your Win Rate</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-value">${(insights?.robotWinRate ?? 0).toFixed(1)}%</div>
                        <div class="summary-label">AI Win Rate</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-value">${insights?.longestHumanStreak || 0}</div>
                        <div class="summary-label">Best Streak</div>
                    </div>
                    <div class="summary-card">
                        <div class="summary-value">${insights?.mostCommonMove || '‚Äî'}</div>
                        <div class="summary-label">Favourite Move</div>
                    </div>
                </div>
                <div class="summary-section">
                    <h3>üéØ Strategy Highlights</h3>
                    <div class="summary-text">
                        <p><strong>Predictability:</strong> ${(insights?.moveVariance ?? 50).toFixed(1)}% ‚Äî ${(insights?.moveVariance ?? 50) > 60 ? 'High (easy to read)' : (insights?.moveVariance ?? 50) > 40 ? 'Moderate balance' : 'Low (unpredictable)'}</p>
                        <p><strong>AI Difficulty:</strong> ${(gameData?.difficulty || currentDifficulty || 'unknown').toUpperCase()} (${(insights?.aiAccuracy ?? 50).toFixed(1)}% prediction accuracy)</p>
                    </div>
                </div>
                <div class="summary-section">
                    <h3>üí° Key Insight</h3>
                    <div class="summary-text">
                        ${insights?.recommendation || 'Keep exploring varied move sequences to stay ahead of the AI.'}
                    </div>
                </div>
                <div class="summary-actions">
                    <button class="btn outline" data-action="analytics">üìä Review Analytics</button>
                    <button class="btn outline" data-action="coach">ü§ñ Ask AI Coach</button>
                    <button class="btn primary" data-action="new-game">üîÑ New Game</button>
                </div>
            `;

            panel.classList.add('visible');
            panel.scrollIntoView({ behavior: 'smooth', block: 'center' });

            const analyticsBtn = panel.querySelector('[data-action="analytics"]');
            if (analyticsBtn) {
                analyticsBtn.addEventListener('click', () => {
                    const analyticsTab = document.querySelector('.mode-tab[data-mode="analytics"]');
                    analyticsTab?.click();
                    panel.scrollIntoView({ behavior: 'smooth', block: 'center' });
                });
            }

            const coachBtn = panel.querySelector('[data-action="coach"]');
            if (coachBtn) {
                coachBtn.addEventListener('click', () => {
                    window.open('/ai_coach_demo', '_blank');
                });
            }

            const newGameBtn = panel.querySelector('[data-action="new-game"]');
            if (newGameBtn) {
                newGameBtn.addEventListener('click', () => {
                    startNewGame();
                });
            }
        }

        function startNewGame() {
            isGameFrozen = false;
            const panel = document.getElementById('endgame-summary-panel');
            if (panel) {
                panel.classList.remove('visible');
                panel.innerHTML = '';
            }
            const calloutElement = document.getElementById('player-performance-callout');
            if (calloutElement) {
                calloutElement.classList.remove('visible');
                calloutElement.textContent = '';
            }
            endgameSummaryShown = false;
            resetGame();
        }
        
        function updateStatusDisplay() {
            // Update the game status to show current AI configuration
            const strategyText = {
                'balanced': 'Balanced Strategy',
                'to_win': 'To Win (Aggressive)',
                'not_to_lose': 'Not to Lose (Defensive)'
            };
            
            const personalityText = {
                'neutral': 'Neutral Personality',
                'aggressive': 'Aggressive Personality',
                'defensive': 'Defensive Personality',
                'adaptive': 'Adaptive Personality',
                'chaotic': 'Chaotic Personality',
                'copycat': 'Copycat Personality'
            };
            
            console.log(`AI Config: ${currentDifficulty} + ${strategyText[currentStrategy]} + ${personalityText[currentPersonality]}`);
        }
        
        function applyPersonalityTheme(personality) {
            // Remove existing personality classes
            document.body.classList.remove('personality-aggressive', 'personality-defensive', 'personality-adaptive', 'personality-chaotic', 'personality-copycat');
            
            // Apply new personality theme
            if (personality !== 'neutral') {
                document.body.classList.add(`personality-${personality}`);
            }
            
            // Update UI elements based on personality
            const gameContainer = document.getElementById('app-root');
            if (gameContainer) {
                const themes = {
                    'neutral': { borderColor: 'rgba(79, 70, 229, 0.35)', backgroundColor: 'var(--bg-surface)' },
                    'aggressive': { borderColor: 'rgba(255, 68, 68, 0.6)', backgroundColor: 'rgba(64, 0, 0, 0.35)' },
                    'defensive': { borderColor: 'rgba(68, 68, 255, 0.6)', backgroundColor: 'rgba(0, 34, 68, 0.35)' },
                    'adaptive': { borderColor: 'rgba(153, 68, 255, 0.6)', backgroundColor: 'rgba(40, 0, 80, 0.35)' },
                    'chaotic': { borderColor: 'rgba(255, 136, 68, 0.6)', backgroundColor: 'rgba(68, 34, 0, 0.35)' },
                    'copycat': { borderColor: 'rgba(68, 255, 68, 0.6)', backgroundColor: 'rgba(0, 68, 34, 0.35)' }
                };
                
                const theme = themes[personality] || themes['neutral'];
                gameContainer.style.borderColor = theme.borderColor;
                gameContainer.style.backgroundColor = theme.backgroundColor;
            }
        }
        
        function exportAnalytics(format) {
            console.log('Exporting analytics in format:', format);
            fetch('/analytics/export?format=' + format)
            .then(res => res.blob())
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'rps_analytics_' + new Date().toISOString().split('T')[0] + '.' + format;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
            })
            .catch(err => {
                console.log('Export failed, creating manual export:', err);
                // Fallback: create manual JSON export with available data only
                const analyticsData = {
                    timestamp: new Date().toISOString(),
                    total_games: parseInt(document.getElementById('rounds').textContent) || 0,
                    wins: parseInt(document.getElementById('wins').textContent) || 0,
                    losses: parseInt(document.getElementById('losses').textContent) || 0,
                    ties: parseInt(document.getElementById('ties').textContent) || 0,
                    note: 'Pattern view analytics have been removed'
                };
                const dataStr = JSON.stringify(analyticsData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'rps_analytics_' + new Date().toISOString().split('T')[0] + '.json';
                a.click();
            });
        }
        
        function showDeveloperMetrics() {
            const metrics = {
                'Page Load Time': 'Fast',
                'API Response Time': 'Good',
                'JavaScript Errors': 'None',
                'Memory Usage': 'Normal',
                'Network Requests': 'Optimized'
            };
            
            let metricsHtml = '<h4>üîß Developer Metrics Console</h4>';
            for (const [key, value] of Object.entries(metrics)) {
                metricsHtml += `<p><strong>${key}:</strong> ${value}</p>`;
            }
            metricsHtml += '<p><em>All systems operational</em></p>';
            
            alert('Developer Metrics:\n\n' + Object.entries(metrics).map(([k,v]) => `${k}: ${v}`).join('\n'));
        }
        
        // Chart Functions
        function initializeCharts() {
            console.log('Initializing charts...');
            try {
                // Move Distribution Pie Chart
                const moveCtx = document.getElementById('moveDistributionChart');
                if (moveCtx) {
                    moveDistributionChart = new Chart(moveCtx, {
                        type: 'pie',
                        data: {
                            labels: ['Paper (P)', 'Rock (R)', 'Scissor (S)'],
                            datasets: [{
                                data: [0, 0, 0],
                                backgroundColor: ['#4CAF50', '#FF9800', '#F44336'],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        color: '#f8fafc',
                                        font: { weight: 'bold', size: 13 }
                                    }
                                }
                            }
                        }
                    });

                    initializePredictionToggle();
                    initializeConfidenceToggle();
                }
                
                // Win Rate Trend Line Chart
                const winCtx = document.getElementById('winRateTrendChart');
                if (winCtx) {
                    winRateTrendChart = new Chart(winCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Win Rate %',
                                data: [],
                                borderColor: '#1976D2',
                                backgroundColor: 'rgba(25, 118, 210, 0.1)',
                                fill: true,
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    ticks: {
                                        color: '#f8fafc',
                                        callback: function(value) {
                                            return value + '%';
                                        }
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.12)'
                                    }
                                },
                                x: {
                                    ticks: {
                                        color: '#f8fafc'
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.08)'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
                
                // Model Prediction Chart
                const modelCtx = document.getElementById('modelPredictionChart');
                if (modelCtx) {
                    modelPredictionChart = new Chart(modelCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Human Move',
                                    data: [],
                                    borderColor: '#FF6384',
                                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    pointRadius: 4
                                },
                                {
                                    label: 'Robot Move',
                                    data: [],
                                    borderColor: '#36A2EB',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    pointRadius: 4,
                                    hidden: true
                                },
                                {
                                    label: 'Random Prediction',
                                    data: [],
                                    borderColor: '#FFCE56',
                                    backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2,
                                    hidden: true
                                },
                                {
                                    label: 'Frequency Prediction',
                                    data: [],
                                    borderColor: '#4BC0C0',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2,
                                    hidden: true
                                },
                                {
                                    label: 'Markov Prediction',
                                    data: [],
                                    borderColor: '#9966FF',
                                    backgroundColor: 'rgba(153, 102, 255, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2,
                                    hidden: true
                                },
                                {
                                    label: 'LSTM Prediction',
                                    data: [],
                                    borderColor: '#6A5ACD',
                                    backgroundColor: 'rgba(106, 90, 205, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2,
                                    hidden: true
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                intersect: false,
                                mode: 'index'
                            },
                            plugins: {
                                legend: {
                                    position: 'top',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 10,
                                        font: {
                                            size: 11
                                        },
                                        color: '#f8fafc'
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Move Number',
                                        color: '#f8fafc',
                                        font: { weight: 'bold' }
                                    },
                                    ticks: {
                                        color: '#f8fafc'
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.08)'
                                    }
                                },
                                y: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Moves',
                                        color: '#f8fafc',
                                        font: { weight: 'bold' }
                                    },
                                    min: -0.5,
                                    max: 2.5,
                                    ticks: {
                                        stepSize: 1,
                                        color: '#f8fafc',
                                        callback: function(value) {
                                            if (value === 0) return 'S';
                                            if (value === 1) return 'R';
                                            if (value === 2) return 'P';
                                            return '';
                                        }
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.12)'
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Score Differential Chart
                const scoreDiffCtx = document.getElementById('scoreDifferentialChart');
                if (scoreDiffCtx) {
                    scoreDifferentialChart = new Chart(scoreDiffCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Score Differential',
                                data: [],
                                borderColor: '#4CAF50',
                                backgroundColor: 'rgba(76, 175, 80, 0.1)',
                                fill: true,
                                tension: 0.3,
                                pointRadius: 3,
                                pointHoverRadius: 5
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    title: {
                                        display: true,
                                        text: 'Score Difference (You - AI)',
                                        color: '#f8fafc',
                                        font: { weight: 'bold' }
                                    },
                                    ticks: {
                                        color: '#f8fafc'
                                    },
                                    grid: {
                                        color: function(context) {
                                            if (context.tick.value === 0) {
                                                return '#f8fafc';
                                            }
                                            return 'rgba(248,250,252,0.12)';
                                        }
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Round Number',
                                        color: '#f8fafc',
                                        font: { weight: 'bold' }
                                    },
                                    ticks: {
                                        color: '#f8fafc'
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.08)'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
                
                // Confidence Trend Chart
                const confidenceCtx = document.getElementById('confidenceTrendChart');
                if (confidenceCtx) {
                    confidenceTrendChart = new Chart(confidenceCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Random',
                                    data: [],
                                    borderColor: 'rgba(255, 206, 86, 1)',
                                    backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                    fill: false,
                                    tension: 0, // Straight lines
                                    hidden: true // Default hidden
                                },
                                {
                                    label: 'Frequency',
                                    data: [],
                                    borderColor: 'rgba(75, 192, 192, 1)',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    fill: false,
                                    tension: 0, // Straight lines
                                    hidden: true // Default hidden
                                },
                                {
                                    label: 'Markov',
                                    data: [],
                                    borderColor: 'rgba(153, 102, 255, 1)',
                                    backgroundColor: 'rgba(153, 102, 255, 0.1)',
                                    fill: false,
                                    tension: 0, // Straight lines
                                    hidden: true // Default hidden
                                },
                                {
                                    label: 'LSTM',
                                    data: [],
                                    borderColor: 'rgba(54, 162, 235, 1)',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: false,
                                    tension: 0, // Straight lines
                                    hidden: true // Default hidden
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 10,
                                        font: { size: 10 },
                                        color: '#f8fafc'
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Move Number',
                                        color: '#f8fafc',
                                        font: { weight: 'bold' }
                                    },
                                    ticks: {
                                        color: '#f8fafc'
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.08)'
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    max: 1,
                                    title: {
                                        display: true,
                                        text: 'Confidence (%)',
                                        color: '#f8fafc',
                                        font: { weight: 'bold' }
                                    },
                                    ticks: {
                                        color: '#f8fafc',
                                        callback: function(value) {
                                            return (value * 100).toFixed(0) + '%';
                                        }
                                    },
                                    grid: {
                                        color: 'rgba(248,250,252,0.12)'
                                    }
                                }
                            }
                        }
                    });
                }
                
                console.log('Charts initialized successfully');
            } catch (error) {
                console.error('Error initializing charts:', error);
            }
        }
        
        let lastChartData = null;

        function updateCharts(data) {
            if (isGameFrozen) return;
            if (!data.human_history || data.human_history.length === 0) return;
            
            try {
                lastChartData = data;
                // Update Move Distribution Chart
                if (moveDistributionChart) {
                    const history = data.human_history;
                    const paperCount = history.filter(m => m === 'paper').length;
                    const rockCount = history.filter(m => m === 'rock').length;
                    const scissorsCount = history.filter(m => m === 'scissors').length;
                    const total = paperCount + rockCount + scissorsCount;
                    let paperPct = 0, rockPct = 0, scissorsPct = 0;
                    if (total > 0) {
                        paperPct = ((paperCount / total) * 100).toFixed(1);
                        rockPct = ((rockCount / total) * 100).toFixed(1);
                        scissorsPct = ((scissorsCount / total) * 100).toFixed(1);
                    }
                    // Update the chart
                    moveDistributionChart.data.datasets[0].data = [paperCount, rockCount, scissorsCount];
                    moveDistributionChart.update('none'); // No animation for performance
                    // Update the percentage display above the chart
                    const pctDiv = document.getElementById('moveDistributionPercentages');
                    if (pctDiv) {
                        pctDiv.innerHTML = `P: <b>${paperPct}%</b> &nbsp; | &nbsp; R: <b>${rockPct}%</b> &nbsp; | &nbsp; S: <b>${scissorsPct}%</b>`;
                    }
                }
                
                // Update Win Rate Trend Chart
                if (winRateTrendChart && data.round > 0) {
                    const winRate = data.stats ? ((data.stats.human_win / data.round) * 100).toFixed(1) : 0;
                    
                    // Keep last 20 data points
                    if (winRateTrendChart.data.labels.length >= 20) {
                        winRateTrendChart.data.labels.shift();
                        winRateTrendChart.data.datasets[0].data.shift();
                    }
                    
                    winRateTrendChart.data.labels.push(`R${data.round}`);
                    winRateTrendChart.data.datasets[0].data.push(parseFloat(winRate));
                    winRateTrendChart.update('none');
                }
                
                // Update Score Differential Chart
                if (scoreDifferentialChart && data.stats) {
                    const scoreDiff = (data.stats.human_win || 0) - (data.stats.robot_win || 0);
                    
                    // Keep last 20 data points for performance
                    if (scoreDifferentialChart.data.labels.length >= 20) {
                        scoreDifferentialChart.data.labels.shift();
                        scoreDifferentialChart.data.datasets[0].data.shift();
                    }
                    
                    scoreDifferentialChart.data.labels.push(`R${data.round}`);
                    scoreDifferentialChart.data.datasets[0].data.push(scoreDiff);
                    
                    // Update line color based on if you're winning or losing
                    const isWinning = scoreDiff > 0;
                    scoreDifferentialChart.data.datasets[0].borderColor = isWinning ? '#4CAF50' : '#F44336';
                    scoreDifferentialChart.data.datasets[0].backgroundColor = isWinning ? 'rgba(76, 175, 80, 0.1)' : 'rgba(244, 67, 54, 0.1)';
                    
                    scoreDifferentialChart.update('none');
                }
                
                // Update Model Prediction Chart
                if (modelPredictionChart && data.human_history && data.robot_history) {
                    const moveToNumber = (move) => {
                        // Unified mapping: 0=rock, 1=paper, 2=scissors
                        if (move === 'rock') return 0;
                        if (move === 'paper') return 1;
                        if (move === 'scissors') return 2;
                        return null;
                    };
                    
                    const humanData = data.human_history.map(moveToNumber);
                    const robotData = data.robot_history.map(moveToNumber);
                    
                    // Use real model predictions from backend
                    const modelPreds = data.model_predictions_history || {};
                    const pad = (arr) => {
                        const copy = Array.isArray(arr) ? arr.slice() : [];
                        while (copy.length < humanData.length) {
                            copy.push(null);
                        }
                        return copy;
                    };

                    const randomPreds = pad((modelPreds.random || []).map(moveToNumber));
                    const frequencyPreds = pad((modelPreds.frequency || []).map(moveToNumber));
                    const markovPreds = pad((modelPreds.markov || []).map(moveToNumber));

                    const labels = Array.from({length: humanData.length}, (_, i) => i + 1);
                    let displayStart = 0;
                    const showAll = document.getElementById('prediction-range-toggle')?.checked;
                    if (!showAll && labels.length > 20) {
                        displayStart = labels.length - 20;
                    }
                    const displayLabels = labels.slice(displayStart);
                    const sliceData = (arr) => (displayStart > 0 ? arr.slice(displayStart) : arr);
                    
                    modelPredictionChart.data.labels = displayLabels;
                    const lstmPreds = pad((modelPreds.lstm || []).map(moveToNumber));
                    const datasets = [humanData, robotData, randomPreds, frequencyPreds, markovPreds, lstmPreds];
                    datasets.forEach((dataset, idx) => {
                        modelPredictionChart.data.datasets[idx].data = sliceData(dataset);
                    });

                    highlightMatches();
                    modelPredictionChart.update('none');
                }
                
                // Helper function to calculate variance
                function calculateVariance(values) {
                    if (values.length === 0) return 0;
                    const mean = values.reduce((a, b) => a + b, 0) / values.length;
                    const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / values.length;
                    return Math.sqrt(variance);
                }
                
                // Update Confidence Trend Chart
                if (confidenceTrendChart && data.model_confidence_history) {
                    const moveNum = data.round;
                    
                    // Use actual confidence values from backend
                    const confidenceValues = {
                        random: data.model_confidence_history.random ? data.model_confidence_history.random[data.model_confidence_history.random.length - 1] || 0 : 0,
                        frequency: data.model_confidence_history.frequency ? data.model_confidence_history.frequency[data.model_confidence_history.frequency.length - 1] || 0 : 0,
                        markov: data.model_confidence_history.markov ? data.model_confidence_history.markov[data.model_confidence_history.markov.length - 1] || 0 : 0,
                        lstm: data.model_confidence_history.lstm ? data.model_confidence_history.lstm[data.model_confidence_history.lstm.length - 1] || 0 : 0
                    };
                    
                    if (confidenceTrendChart.data.labels.length > 20) {
                        // Keep only last 20 moves for performance
                        confidenceTrendChart.data.labels.shift();
                        confidenceTrendChart.data.datasets.forEach(dataset => dataset.data.shift());
                    }
                    
                    confidenceTrendChart.data.labels.push(moveNum);
                    confidenceTrendChart.data.datasets[0].data.push(confidenceValues.random);
                    confidenceTrendChart.data.datasets[1].data.push(confidenceValues.frequency);
                    confidenceTrendChart.data.datasets[2].data.push(confidenceValues.markov);
                    confidenceTrendChart.data.datasets[3].data.push(confidenceValues.lstm);
                    confidenceTrendChart.update('none');
                }
                
                // Update Model Metrics Table
                updateModelMetrics(data);
                
                // Update Recommended Strategy
                updateRecommendedStrategy(data);
                
                // Update Debug Panel
                updateDebugPanel(data);
                
            } catch (error) {
                console.error('Error updating charts:', error);
            }
        }
        
        // Model Metrics Functions
        function updateModelMetrics(data) {
            const metricsContainer = document.getElementById('modelMetricsTable');
            if (!metricsContainer || !data.accuracy) return;
            
            const models = [
                { name: 'Random', key: 'random', color: '#FFCE56' },
                { name: 'Frequency', key: 'frequency', color: '#4BC0C0' },
                { name: 'Markov', key: 'markov', color: '#9966FF' },
                { name: 'LSTM Neural', key: 'lstm', color: '#6A5ACD' }
            ];
            
            metricsContainer.innerHTML = models.map(model => {
                const accuracy = data.accuracy[model.key] || 0;
                
                return `
                    <div style="background: linear-gradient(135deg, ${model.color}20, ${model.color}10); border-left: 4px solid ${model.color}; padding: 15px; border-radius: 8px;">
                        <h6 style="margin: 0 0 8px 0; color: #f8fafc; font-weight: bold;">${model.name} Strategy</h6>
                        <div style="font-size: 24px; font-weight: bold; color: ${model.color}; margin-bottom: 5px;">${accuracy.toFixed(1)}%</div>
                        <div style="color: #e2e8f0; font-size: 13px; font-weight: 500;">
                            Status: ${accuracy > 50 ? 'üü¢ Excellent' : accuracy >= 33 ? 'üü° Good' : 'üî¥ Needs Improvement'}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateRecommendedStrategy(data) {
            const recommendationEl = document.getElementById('recommendedStrategy');
            if (!recommendationEl || !data.accuracy) return;
            
            const accuracies = data.accuracy;
            const bestModel = Object.keys(accuracies).reduce((best, current) => 
                (accuracies[current] || 0) > (accuracies[best] || 0) ? current : best
            );
            
            const bestAccuracy = accuracies[bestModel] || 0;
            const modelNames = {
                'random': 'Random Strategy',
                'frequency': 'Frequency Analysis',
                'markov': 'Markov Chain',
                'lstm': 'LSTM Neural',
                'to_win': 'To Win (Aggressive)',
                'not_to_lose': 'Not to Lose (Defensive)'
            };
            
            const recommendation = bestAccuracy > 60 ? 
                `üèÜ ${modelNames[bestModel]} (${bestAccuracy.toFixed(1)}% accuracy)` :
                `üîÑ Continue analyzing patterns (Best: ${modelNames[bestModel]} at ${bestAccuracy.toFixed(1)}%)`;
                
            recommendationEl.innerHTML = `
                <div style="color: ${bestAccuracy > 60 ? '#4CAF50' : '#FF9800'};">
                    ${recommendation}
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    ${data.round < 10 ? 'Play more rounds for better analysis' : 'Pattern analysis complete'}
                </div>
            `;
        }
        
        // Debug Data Display Function
        function updateDebugPanel(data) {
            if (!data.debug_accuracy) return;
            
            const debugData = data.debug_accuracy;
            
            const displayHtml = `
                <div style="font-family: monospace; color: #e2e8f0; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; margin: 10px 0;">
                    <h4 style="color: #fbbf24; margin: 0 0 15px 0;">üîç Debug: Prediction vs Reality Analysis</h4>
                    
                    ${Object.keys(debugData).map(modelName => {
                        const modelDebug = debugData[modelName];
                        
                        return `
                            <div style="margin: 20px 0; border: 1px solid #4a5568; border-radius: 6px; padding: 15px;">
                                <h5 style="color: #81c784; margin: 0 0 10px 0; text-transform: uppercase;">${modelName} Model</h5>
                                
                                <div style="margin: 10px 0; padding: 10px; background: rgba(59, 130, 246, 0.1); border-radius: 4px; border-left: 3px solid #3b82f6;">
                                    <strong style="color: #3b82f6;">üìä Summary</strong><br>
                                    <div style="margin: 5px 0; font-size: 13px;">
                                        AI Strategy Accuracy: <strong>${modelDebug.ai_strategy_accuracy}%</strong><br>
                                        Current Method (Wrong): <strong>${modelDebug.current_method?.accuracy_percentage || 0}%</strong><br>
                                        Correct Method (Right): <strong>${modelDebug.correct_method?.accuracy_percentage || 0}%</strong><br>
                                        Discrepancy: <strong style="color: ${Math.abs((modelDebug.ai_strategy_accuracy || 0) - (modelDebug.correct_method?.accuracy_percentage || 0)) > 5 ? '#ef4444' : '#22c55e'}">${Math.abs((modelDebug.ai_strategy_accuracy || 0) - (modelDebug.correct_method?.accuracy_percentage || 0)).toFixed(1)}%</strong>
                                    </div>
                                </div>
                                
                                <details style="margin: 10px 0;">
                                    <summary style="cursor: pointer; color: #60a5fa; margin: 10px 0;">üìä View Raw Prediction Data</summary>
                                    <div style="margin: 10px 0; font-size: 12px;">
                                        <div style="margin: 10px 0; padding: 10px; background: rgba(239, 68, 68, 0.1); border-radius: 4px; border-left: 3px solid #ef4444;">
                                            <strong style="color: #ef4444;">‚ùå Current Method (Wrong): predictions[i] vs human_history[i]</strong>
                                            <div style="max-height: 200px; overflow-y: auto; border: 1px solid #4a5568; padding: 5px; margin: 5px 0; font-size: 11px;">
                                                ${(modelDebug.current_method?.comparisons || []).map(comp => 
                                                    `<div style="margin: 2px 0; padding: 3px; background: rgba(255,255,255,0.05); border-radius: 2px;">
                                                        <strong>Round ${comp.round}:</strong> Predicted "${comp.predicted}" vs Actual "${comp.actual}" ‚Üí ${comp.correct ? '‚úÖ Match' : '‚ùå Miss'}
                                                        <br><small style="color: #94a3b8;">${comp.note}</small>
                                                    </div>`
                                                ).join('')}
                                            </div>
                                            <div style="margin: 5px 0; font-weight: bold;">
                                                Result: ${modelDebug.current_method?.correct_count || 0}/${modelDebug.current_method?.comparisons?.length || 0} = ${modelDebug.current_method?.accuracy_percentage || 0}%
                                            </div>
                                        </div>
                                        
                                        <div style="margin: 10px 0; padding: 10px; background: rgba(34, 197, 94, 0.1); border-radius: 4px; border-left: 3px solid #22c55e;">
                                            <strong style="color: #22c55e;">‚úÖ Correct Method (Right): predictions[i] vs human_history[i+1]</strong>
                                            <div style="max-height: 200px; overflow-y: auto; border: 1px solid #4a5568; padding: 5px; margin: 5px 0; font-size: 11px;">
                                                ${(modelDebug.correct_method?.comparisons || []).map(comp => 
                                                    `<div style="margin: 2px 0; padding: 3px; background: rgba(255,255,255,0.05); border-radius: 2px;">
                                                        <strong>Round ${comp.round}:</strong> Predicted "${comp.predicted}" vs Actual "${comp.actual}" ‚Üí ${comp.correct ? '‚úÖ Match' : '‚ùå Miss'}
                                                        <br><small style="color: #94a3b8;">${comp.note}</small>
                                                    </div>`
                                                ).join('')}
                                            </div>
                                            <div style="margin: 5px 0; font-weight: bold;">
                                                Result: ${modelDebug.correct_method?.correct_count || 0}/${modelDebug.correct_method?.comparisons?.length || 0} = ${modelDebug.correct_method?.accuracy_percentage || 0}%
                                            </div>
                                        </div>
                                    </div>
                                </details>
                            </div>
                        `;
                    }).join('')}
                    
                    <div style="margin: 20px 0; padding: 15px; background: rgba(59, 130, 246, 0.1); border-radius: 6px; border-left: 3px solid #3b82f6;">
                        <h5 style="color: #3b82f6; margin: 0 0 10px 0;">üìã Key Findings</h5>
                        <p style="margin: 5px 0; font-size: 13px; line-height: 1.5;">
                            <strong>Issue:</strong> The current backend compares predictions[i] with human_history[i], but predictions[i] was made to predict human_history[i+1].<br>
                            <strong>Fix:</strong> Change the comparison to predictions[i] vs human_history[i+1] to get the correct accuracy calculation.<br>
                            <strong>Impact:</strong> This explains the discrepancy between Model Prediction Tracking and AI Strategy Accuracy values.
                        </p>
                    </div>
                </div>
            `;
            
            document.getElementById('debugDataDisplay').innerHTML = displayHtml;
        }
        
        function toggleDebugData() {
            const debugContent = document.getElementById('debugAccuracyData');
            if (debugContent.style.display === 'none') {
                debugContent.style.display = 'block';
                // If debug data is empty, fetch fresh data
                if (!document.getElementById('debugDataDisplay').innerHTML.trim()) {
                    fetch('/history')
                    .then(res => res.json())
                    .then(data => {
                        if (data.debug_accuracy) {
                            updateDebugPanel(data);
                        }
                    })
                    .catch(err => console.log('Failed to fetch debug data:', err));
                }
            } else {
                debugContent.style.display = 'none';
            }
        }
        
        // LLM Type Management
        function updateLLMType() {
            // LLM Type selector functionality has been removed with Coach View cleanup
            console.log('LLM Type selector is no longer available - Coach View has been simplified');
        }
        
        // Coaching Functions
        async function refreshCoachingTips() {
            try {
                const response = await fetch('/coaching');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                // Use enhanced_tips if available, fallback to coaching_tips
                const tips = result.enhanced_tips || result.coaching_tips || [];
                updateCoachingDisplay(tips);
                
                // Also update performance stats when refreshing coaching
                const gameResponse = await fetch('/game_data');
                if (gameResponse.ok) {
                    const gameData = await gameResponse.json();
                    updateCoachingStats(gameData);
                }
            } catch (error) {
                console.error('Failed to fetch coaching tips:', error);
                showCoachingError('Unable to fetch coaching tips. Please try again.');
            }
        }
        
        function updateCoachingDisplay(tips) {
            const container = document.getElementById('coaching-tips-container');
            
            if (!tips || tips.length === 0) {
                container.innerHTML = `
                    <div class="coaching-tip-placeholder">
                        <p>üéÆ Play at least 5 rounds to receive personalized coaching tips!</p>
                        <p>Tips will analyze your patterns and provide strategic guidance.</p>
                    </div>
                `;
                return;
            }
            
            // Handle both enhanced tip objects and simple string arrays
            let processedTips = tips;
            if (tips.length > 0 && typeof tips[0] === 'object' && tips[0].tip) {
                // Enhanced tips format - already sorted by priority in backend
                processedTips = tips.slice(0, 3);
            } else {
                // Simple string format - convert to objects
                processedTips = tips.slice(0, 3).map((tip, index) => ({
                    tip: tip,
                    priority: 5.0,  // Default priority
                    category: 'general'
                }));
            }
            
            container.innerHTML = processedTips.map((tipObj, index) => {
                const priority = tipObj.priority || 5.0;
                const priorityClass = priority >= 8 ? 'priority-high' : 
                                   priority >= 5 ? 'priority-medium' : 'priority-low';
                const priorityLabel = priority >= 8 ? 'üî• High Priority' : 
                                     priority >= 5 ? '‚ö° Medium Priority' : 'üí° Low Priority';
                
                return `
                    <div class="coaching-tip ${priorityClass}">
                        <div class="coaching-tip-priority">${priorityLabel}</div>
                        <div class="coaching-tip-content">${tipObj.tip}</div>
                    </div>
                `;
            }).join('');
        }
        
        function showCoachingError(message) {
            const container = document.getElementById('coaching-tips-container');
            container.innerHTML = `
                <div class="coaching-tip-placeholder">
                    <p>‚ö†Ô∏è ${message}</p>
                </div>
            `;
        }
        
        // Performance Charts - Global variables
        let predictabilityChart = null;
        let patternChart = null;
        let adaptationChart = null;
        let performanceData = {
            rounds: [],
            predictability: [],
            patternStrength: [],
            adaptationRate: []
        };
        
        function initializePerformanceCharts() {
            // Initialize Predictability Chart
            const predictabilityCtx = document.getElementById('predictability-chart');
            if (predictabilityCtx) {
                predictabilityChart = new Chart(predictabilityCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Predictability %',
                            data: [],
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                ticks: { color: '#94a3b8' },
                                grid: { color: 'rgba(34, 197, 94, 0.1)' }
                            },
                            x: {
                                ticks: { color: '#94a3b8' },
                                grid: { color: 'rgba(34, 197, 94, 0.1)' }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: '#22c55e' } }
                        }
                    }
                });
            }
            
            // Initialize Pattern Strength Chart
            const patternCtx = document.getElementById('pattern-chart');
            if (patternCtx) {
                patternChart = new Chart(patternCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Pattern Strength',
                            data: [],
                            borderColor: '#f59e0b',
                            backgroundColor: 'rgba(245, 158, 11, 0.1)',
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                ticks: { color: '#94a3b8' },
                                grid: { color: 'rgba(34, 197, 94, 0.1)' }
                            },
                            x: {
                                ticks: { color: '#94a3b8' },
                                grid: { color: 'rgba(34, 197, 94, 0.1)' }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: '#22c55e' } }
                        }
                    }
                });
            }
            
            // Initialize Adaptation Rate Chart
            const adaptationCtx = document.getElementById('adaptation-chart');
            if (adaptationCtx) {
                adaptationChart = new Chart(adaptationCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Adaptation Rate %',
                            data: [],
                            borderColor: '#22c55e',
                            backgroundColor: 'rgba(34, 197, 94, 0.1)',
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                ticks: { color: '#94a3b8' },
                                grid: { color: 'rgba(34, 197, 94, 0.1)' }
                            },
                            x: {
                                ticks: { color: '#94a3b8' },
                                grid: { color: 'rgba(34, 197, 94, 0.1)' }
                            }
                        },
                        plugins: {
                            legend: { labels: { color: '#22c55e' } }
                        }
                    }
                });
            }
        }
        
        function updateCoachingStats(gameData) {
            const humanMoves = gameData.human_moves || [];
            const robotMoves = gameData.robot_moves || [];
            const results = gameData.results || [];
            const round = gameData.round || 0;
            
            if (!gameData || round < 5) {
                // Not enough data for meaningful stats
                document.getElementById('current-predictability').textContent = 'Insufficient Data';
                document.getElementById('current-pattern').textContent = 'Insufficient Data';
                document.getElementById('current-adaptation').textContent = 'Insufficient Data';
                return;
            }
            
            // Calculate metrics for the latest data point
            const windowSize = Math.min(10, humanMoves.length);
            const recentMoves = humanMoves.slice(-windowSize);
            const recentResults = results.slice(-windowSize);
            
            const predictability = calculatePredictability(recentMoves);
            const patternStrength = calculatePatternStrengthScore(recentMoves);
            const adaptationRate = calculateAdaptationRate(humanMoves, results);
            
            // Update current stats display
            document.getElementById('current-predictability').textContent = `${(predictability * 100).toFixed(1)}%`;
            document.getElementById('current-pattern').textContent = `${patternStrength.toFixed(1)}%`;
            document.getElementById('current-adaptation').textContent = `${(adaptationRate * 100).toFixed(1)}%`;
            
            // Update charts if we have enough data and the round is divisible by 2 (to avoid too many updates)
            if (round >= 5 && round % 2 === 0) {
                updatePerformanceCharts(round, predictability * 100, patternStrength, adaptationRate * 100);
            }
        }
        
        function updatePerformanceCharts(round, predictability, patternStrength, adaptationRate) {
            const maxDataPoints = 20; // Keep only last 20 data points for readability
            
            // Add new data point
            performanceData.rounds.push(round);
            performanceData.predictability.push(predictability);
            performanceData.patternStrength.push(patternStrength);
            performanceData.adaptationRate.push(adaptationRate);
            
            // Trim data if too many points
            if (performanceData.rounds.length > maxDataPoints) {
                performanceData.rounds = performanceData.rounds.slice(-maxDataPoints);
                performanceData.predictability = performanceData.predictability.slice(-maxDataPoints);
                performanceData.patternStrength = performanceData.patternStrength.slice(-maxDataPoints);
                performanceData.adaptationRate = performanceData.adaptationRate.slice(-maxDataPoints);
            }
            
            // Update charts
            if (predictabilityChart) {
                predictabilityChart.data.labels = performanceData.rounds;
                predictabilityChart.data.datasets[0].data = performanceData.predictability;
                predictabilityChart.update('none'); // No animation for smoother updates
            }
            
            if (patternChart) {
                patternChart.data.labels = performanceData.rounds;
                patternChart.data.datasets[0].data = performanceData.patternStrength;
                patternChart.update('none');
            }
            
            if (adaptationChart) {
                adaptationChart.data.labels = performanceData.rounds;
                adaptationChart.data.datasets[0].data = performanceData.adaptationRate;
                adaptationChart.update('none');
            }
        }
        
        function calculatePredictability(moves) {
            if (moves.length < 3) return 0;
            
            // Calculate entropy-based predictability
            const counts = { 'rock': 0, 'paper': 0, 'scissors': 0 };
            moves.forEach(move => counts[move]++);
            
            const total = moves.length;
            let entropy = 0;
            Object.values(counts).forEach(count => {
                if (count > 0) {
                    const p = count / total;
                    entropy -= p * Math.log2(p);
                }
            });
            
            // Convert entropy to predictability (lower entropy = higher predictability)
            const maxEntropy = Math.log2(3); // Maximum entropy for 3 choices
            return 1 - (entropy / maxEntropy);
        }
        
        function calculatePatternStrengthScore(moves) {
            if (moves.length < 4) return 0;
            
            let patternScore = 0;
            const patterns = [
                // Repeating patterns
                (m) => m[0] === m[1] && m[1] === m[2], // AAA
                (m) => m[0] === m[2] && m[1] !== m[0], // ABA
                // Cycling patterns
                (m) => isRockPaperScissorsSequence(m.slice(0, 3)),
                (m) => isScissorsPaperRockSequence(m.slice(0, 3))
            ];
            
            for (let i = 0; i <= moves.length - 3; i++) {
                const window = moves.slice(i, i + 3);
                patterns.forEach(pattern => {
                    if (pattern(window)) patternScore++;
                });
            }
            
            return Math.min(100, (patternScore / (moves.length - 2)) * 100);
        }
        
        function isRockPaperScissorsSequence(moves) {
            const sequence = ['rock', 'paper', 'scissors'];
            return moves.every((move, i) => move === sequence[i]);
        }
        
        function isScissorsPaperRockSequence(moves) {
            const sequence = ['scissors', 'paper', 'rock'];
            return moves.every((move, i) => move === sequence[i]);
        }
        
        function calculateAdaptationRate(humanMoves, results) {
            if (humanMoves.length < 10) return 0;
            
            // Compare recent performance vs earlier performance
            const windowSize = Math.min(5, Math.floor(humanMoves.length / 2));
            const recentResults = results.slice(-windowSize);
            const earlierResults = results.slice(-windowSize * 2, -windowSize);
            
            const recentWinRate = recentResults.filter(r => r === 'human').length / recentResults.length;
            const earlierWinRate = earlierResults.filter(r => r === 'human').length / earlierResults.length;
            
            // Adaptation rate is the improvement (or decline) in performance
            return Math.max(0, recentWinRate - earlierWinRate + 0.5); // Add 0.5 to normalize around 50%
        }
        
        function setDifficulty() {
            currentDifficulty = document.getElementById('difficulty').value;
            console.log('Difficulty set to:', currentDifficulty);
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
            updateSelectedModelVisibility(); // Update confidence chart visibility
        }
        
        function setStrategy() {
            currentStrategy = document.getElementById('strategy').value;
            console.log('Strategy set to:', currentStrategy);
            updateStatusDisplay();
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
        }
        
        function setPersonality() {
            currentPersonality = document.getElementById('personality').value;
            console.log('Personality set to:', currentPersonality);
            updateStatusDisplay();
            applyPersonalityTheme(currentPersonality);
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
            updateRobotConversation(currentPersonality, 'start');
        }
        
        function setLLMBanterMode() {
            const toggle = document.getElementById('llm-banter-toggle');
            useLLMBanter = toggle.value === 'true';
            console.log('LLM Banter mode set to:', useLLMBanter);
            
            // Update the conversation heading to reflect current mode
            const conversationHeading = document.querySelector('.conversation-heading span');
            if (conversationHeading) {
                conversationHeading.textContent = useLLMBanter ? 
                    'AI-generated personality banter.' : 
                    'Rule-based personality responses.';
            }
            
            // Regenerate current conversation with new mode
            updateRobotConversation(currentPersonality, 'start');
        }
        
        function setGameLength() {
            const gameLength = document.getElementById('game-length').value;
            currentGameLimit = gameLength === 'infinite' ? null : parseInt(gameLength);
            console.log('Game length set to:', currentGameLimit);
            
            // Show notification only if called from dropdown change (not initial load)
            if (document.readyState === 'complete') {
                const notification = document.createElement('div');
                notification.className = 'game-notification';
                notification.innerHTML = currentGameLimit 
                    ? `üéØ Game limited to ${currentGameLimit} rounds`
                    : '‚ôæÔ∏è Game set to unlimited rounds';
                notification.style.cssText = `
                    position: fixed; top: 20px; right: 20px; z-index: 10000;
                    background: var(--accent-color); color: white; padding: 15px 20px;
                    border-radius: 8px; font-weight: bold; animation: slideIn 0.3s ease;
                `;
                document.body.appendChild(notification);
                setTimeout(() => {
                    notification.style.animation = 'slideOut 0.3s ease';
                    setTimeout(() => notification.remove(), 300);
                }, 2000);
            }
        }
        
        
        function resetGame() {
            fetch('/reset', {method: 'POST'})
            .then(res => res.json())
            .then(() => location.reload())
            .catch(error => {
                console.error('Reset error:', error);
                location.reload();
            });
        }
        
        // üéÆ ENHANCED REPLAY FUNCTIONS (New Feature #1)
        function saveCurrentReplay() {
            const name = prompt('Enter a name for this replay:', 'Game Session ' + new Date().toLocaleString());
            if (name) {
                const notes = prompt('Enter any notes (optional):', '');
                const formData = new FormData();
                formData.append('name', name);
                formData.append('notes', notes || '');
                
                fetch('/replay/save', {
                    method: 'POST',
                    body: formData
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        alert(`‚úÖ Replay saved successfully!\nSession ID: ${data.session_id}\nTotal rounds: ${data.total_rounds}`);
                    } else {
                        alert(`‚ùå Failed to save replay: ${data.message}`);
                    }
                })
                .catch(err => {
                    alert('‚ùå Error saving replay: ' + err.message);
                });
            }
        }
        
        // Disabled Tournament Message Function
        function showDisabledMessage(message) {
            const notification = document.createElement('div');
            notification.textContent = message;
            notification.className = 'disabled-notification';
            document.body.appendChild(notification);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        console.log('Main page script loaded successfully');
    </script>
</body>
</html>
