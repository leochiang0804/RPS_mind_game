<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paper Scissor Stone ML Game</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/experimental-theme.css') }}">
</head>
<body class="experimental-ui">
    <div class="app-wrapper personality-theme" id="app-root">
        <div class="app-content">
            <header class="app-header">
                <div class="app-title-group">
                    <h1 class="app-title">Paper Scissor Stone ML Arena</h1>
                    <p class="app-subtitle">Challenge adaptive AI opponents with live analytics, coaching intelligence, and cinematic battle visuals.</p>
                    <div class="badge-deck">
                        <span class="badge">ğŸ§  Adaptive ML</span>
                        <span class="badge">ğŸ“ˆ Live Analytics</span>
                        <span class="badge">ğŸ¤– Personality Engine</span>
                        <span class="badge">ğŸ† Tournament Ready</span>
                    </div>
                </div>
                <div class="header-actions">
                    <button class="pill-button gradient-success" onclick="saveCurrentReplay()">ğŸ’¾ Save Current Replay</button>
                    <button class="pill-button gradient-info" onclick="window.open('/replay/dashboard', '_blank')">ğŸ¬ View All Replays</button>
                    <button class="pill-button" onclick="window.open('/developer', '_blank')">ğŸ”§ Developer Console</button>
                    <button class="pill-button gradient-danger" onclick="window.open('/performance', '_blank')">âš¡ Performance Dashboard</button>
                </div>
            </header>

            <section class="panel status-panel" id="strategy-monitor">
                <div class="panel-heading">
                    <h2 class="panel-title">Adaptive Strategy Monitor</h2>
                    <span class="panel-subtitle">Live look at how the AI is approaching the next round.</span>
                </div>
                <div class="status-value">
                    Current Strategy: <span id="current-strategy-text">Analyzing...</span>
                </div>
            </section>

            <section class="panel controls-panel" id="control-center">
                <div class="panel-heading">
                    <h2 class="panel-title">Opponent Control Center</h2>
                    <span class="panel-subtitle">Blend difficulty, tactic, and personality to craft your rival.</span>
                </div>
                <div class="control-grid">
                    <div class="control-row">
                        <div class="select-card">
                            <label for="difficulty">ğŸ¯ AI Difficulty</label>
                            <select id="difficulty" onchange="setDifficulty()">
                                <option value="random" {{ 'selected' if default_difficulty == 'random' else '' }}>Random</option>
                                <option value="frequency" {{ 'selected' if default_difficulty == 'frequency' else '' }}>Frequency</option>
                                <option value="markov" {{ 'selected' if default_difficulty == 'markov' else '' }}>Markov</option>
                                <option value="enhanced" {{ 'selected' if default_difficulty == 'enhanced' else '' }}>Enhanced ML</option>
                                <option value="lstm" {{ 'selected' if default_difficulty == 'lstm' else '' }}>LSTM Neural</option>
                            </select>
                        </div>
                        <div class="select-card">
                            <label for="strategy">âš”ï¸ AI Strategy</label>
                            <select id="strategy" onchange="setStrategy()">
                                <option value="balanced">ğŸ¯ Balanced</option>
                                <option value="to_win">ğŸ—¡ï¸ To Win (Aggressive)</option>
                                <option value="not_to_lose">ğŸ›¡ï¸ Not to Lose (Defensive)</option>
                            </select>
                        </div>
                        <div class="select-card">
                            <label for="personality">ğŸ¤– AI Personality</label>
                            <select id="personality" onchange="setPersonality()">
                                <option value="neutral">ğŸ˜ Neutral</option>
                                <option value="berserker">âš”ï¸ The Berserker (Ultra Aggressive)</option>
                                <option value="guardian">ğŸ›¡ï¸ The Guardian (Defensive Expert)</option>
                                <option value="chameleon">ğŸ¦ The Chameleon (Adaptive)</option>
                                <option value="professor">ğŸ”¬ The Professor (Analytical)</option>
                                <option value="wildcard">ğŸƒ The Wildcard (Unpredictable)</option>
                                <option value="mirror">ğŸª The Mirror (Mimicking)</option>
                            </select>
                        </div>
                    </div>
                </div>
                <div class="control-actions">
                    <button class="btn outline" onclick="testRobotUpdate()">ğŸ”§ Test Update</button>
                </div>
                <div id="robot-character-display" class="robot-profile">
                    <div id="robot-avatar" class="robot-avatar">
                        <span class="avatar-emoji">ğŸ¤–</span>
                        <div id="strategy-symbol" class="strategy-icon">âš”ï¸</div>
                    </div>
                    <div class="robot-meta">
                        <div class="meta-title"><span id="robot-name">Standard Robot</span></div>
                        <div class="meta-tags">
                            <span class="tag">Difficulty: <span id="robot-difficulty">Easy</span></span>
                            <span class="tag">Strategy: <span id="robot-strategy">Random</span></span>
                            <span class="tag">Personality: <span id="robot-personality">Balanced</span></span>
                        </div>
                    </div>
                </div>
            </section>

            <section id="robot-conversation" class="panel conversation-panel">
                <div class="panel-heading">
                    <h2 class="panel-title">AI Comms Channel</h2>
                    <span class="panel-subtitle">Live banter from your opponent.</span>
                </div>
                <div class="conversation-body">
                    <div id="conversation-avatar" class="conversation-avatar">ğŸ¤–</div>
                    <div class="conversation-content">
                        <div class="speech-bubble">
                            <div id="robot-speech">"Ready for battle? Let's see what you've got!"</div>
                            <span class="speech-tail"></span>
                        </div>
                        <div class="conversation-meta">
                            <span id="robot-mood">ğŸ˜ Confident</span>
                        </div>
                    </div>
                </div>
            </section>

            <section class="panel move-panel">
                <div class="panel-heading">
                    <h2 class="panel-title">Cinematic Battle Arena</h2>
                    <span class="panel-subtitle">Moves, highlights, and round results.</span>
                </div>
                <div id="move-display-window" class="move-display">
                    <div id="human-move-display" class="move-display-card">
                        <h3 class="move-title">You</h3>
                        <div class="move-visual">
                            <img id="human-move-img" src="/static/paper.png" alt="Your Move" style="display: none;">
                            <span id="human-move-text">Choose your move</span>
                        </div>
                    </div>
                    <div class="move-display-card vs-card">
                        <div id="round-result" class="round-result" style="display: none;">Round Result</div>
                    </div>
                    <div id="robot-move-display" class="move-display-card">
                        <h3 class="move-title">Robot</h3>
                        <div class="move-visual">
                            <img id="robot-move-img" src="/static/paper.png" alt="Robot Move" style="display: none;">
                            <span id="robot-move-text">Thinking...</span>
                        </div>
                    </div>
                </div>
                <div class="move-pad">
                    <button type="button" id="move-paper" class="move-btn" onclick="submitMove('paper')">Paper (P)</button>
                    <button type="button" id="move-stone" class="move-btn" onclick="submitMove('stone')">Rock (R)</button>
                    <button type="button" id="move-scissor" class="move-btn" onclick="submitMove('scissor')">Scissor (S)</button>
                </div>
                <div class="control-actions">
                    <button class="btn destructive" onclick="resetGame()">ğŸ”„ Reset Game</button>
                    <button class="btn primary" onclick="exportAnalytics()">ğŸ“Š Export Data</button>
                    <button class="btn" onclick="showTournamentDashboard()">ğŸ† Tournament</button>
                </div>
            </section>

            <div id="result" class="result-banner">
                Press buttons or use A, W, D keys to play!
            </div>

            <section class="panel stats-panel">
                <div class="panel-heading">
                    <h2 class="panel-title">Match Scoreboard</h2>
                    <span class="panel-subtitle">Track the overall duel momentum.</span>
                </div>
                <div class="stat-grid">
                    <div class="stat-card">
                        <h4>Rounds</h4>
                        <div id="rounds" class="stat-value">{{ round }}</div>
                    </div>
                    <div class="stat-card">
                        <h4>Your Wins</h4>
                        <div id="human-wins" class="stat-value">{{ stats.human_win }}</div>
                    </div>
                    <div class="stat-card">
                        <h4>Computer Wins</h4>
                        <div id="robot-wins" class="stat-value">{{ stats.robot_win }}</div>
                    </div>
                    <div class="stat-card">
                        <h4>Ties</h4>
                        <div id="ties" class="stat-value">{{ stats.tie }}</div>
                    </div>
                </div>
            </section>

            <section class="panel analytics-panel">
                <div class="panel-heading">
                    <h2 class="panel-title">Visual Analytics</h2>
                    <span class="panel-subtitle">Real-time visuals of strategy performance.</span>
                </div>
                <div class="cards-grid">
                    <div class="chart-card">
                        <h4>Move Distribution</h4>
                        <canvas id="moveDistributionChart"></canvas>
                    </div>
                    <div class="chart-card">
                        <h4>Win Rate Trend</h4>
                        <canvas id="winRateTrendChart"></canvas>
                    </div>
                </div>
                <div class="cards-grid">
                    <div class="chart-card">
                        <h4>Strategy Timeline</h4>
                        <canvas id="strategyTimelineChart"></canvas>
                    </div>
                    <div class="chart-card">
                        <h4>ğŸ¤– Model Prediction Tracking</h4>
                        <p class="chart-hint">Compare human moves vs robot moves vs all model predictions (Paper=2, Rock=1, Scissor=0)</p>
                        <canvas id="modelPredictionChart"></canvas>
                    </div>
                </div>
                <div class="cards-grid">
                    <div class="chart-card">
                        <h4>ğŸ§  ML Model Comparison</h4>
                        <div class="cards-grid">
                            <div class="chart-card">
                                <h5>Model Accuracy Comparison</h5>
                                <canvas id="modelAccuracyChart"></canvas>
                            </div>
                            <div class="chart-card">
                                <h5>Prediction Confidence Trends</h5>
                                <canvas id="confidenceTrendChart"></canvas>
                            </div>
                        </div>
                        <div class="metric-board">
                            <h5 class="metric-title">ğŸ“Š Model Performance Metrics</h5>
                            <div id="modelMetricsTable" class="metric-grid"></div>
                            <div class="recommended-strategy" id="recommendedStrategy">Analyzing performance...</div>
                        </div>
                    </div>
                </div>
            </section>

            <section class="panel history-panel">
                <div class="panel-heading">
                    <h2 class="panel-title">Recent History</h2>
                    <span class="panel-subtitle">Last ten moves at a glance.</span>
                </div>
                <p><strong>Your moves:</strong> <span id="recent-human">{{ human_history[-10:]|join(', ') }}</span></p>
                <p><strong>Computer moves:</strong> <span id="recent-robot">{{ robot_history[-10:]|join(', ') }}</span></p>
            </section>

            <section class="panel coach-panel">
                <div class="panel-heading">
                    <h2 class="panel-title">ğŸ“ AI Coach</h2>
                    <span class="panel-subtitle">Personalized insights and experiments.</span>
                </div>
                <div class="secondary-panel">
                    <div class="panel coach-card">
                        <div class="panel-heading">
                            <h4 class="panel-title">ğŸ’¡ Your Strategy Tips</h4>
                            <button class="btn primary" onclick="refreshCoachingTips()">ğŸ”„ Get New Tips</button>
                        </div>
                        <div id="coaching-tips-list" class="coach-content">
                            <p>Play a few rounds to get personalized coaching tips!</p>
                        </div>
                    </div>
                    <div class="panel coach-card">
                        <div class="panel-heading">
                            <h4 class="panel-title">ğŸ§ª Experiments to Try</h4>
                        </div>
                        <div id="experiments-list" class="coach-content">
                            <p>Suggested strategies will appear here!</p>
                        </div>
                    </div>
                </div>
                <div id="insights-summary" class="panel insights-panel" style="display: none;">
                    <div class="panel-heading">
                        <h4 class="panel-title">ğŸ“Š Pattern Analysis</h4>
                    </div>
                    <div id="insights-content" class="coach-content"></div>
                </div>
            </section>

            <section class="panel advanced-analytics-panel">
                <div class="panel-heading">
                    <h2 class="panel-title">Advanced Analytics Dashboard</h2>
                    <span class="panel-subtitle">Deep dive into trends, randomness, and adaptability.</span>
                </div>
                <div class="cards-grid">
                    <div class="analytics-card">
                        <h4>ğŸ¯ Predictability Score</h4>
                        <div id="predictability-score" class="metric-value">--</div>
                        <div id="predictability-status" class="metric-caption">Analyzing...</div>
                    </div>
                    <div class="analytics-card">
                        <h4>ğŸ† Win Rate Trend</h4>
                        <div id="win-rate-trend" class="metric-value">--</div>
                        <div id="trend-status" class="metric-caption">Recent 10 games</div>
                    </div>
                    <div class="analytics-card">
                        <h4>ğŸ”„ Strategy Changes</h4>
                        <div id="strategy-changes-count" class="metric-value">--</div>
                        <div id="changes-status" class="metric-caption">Adaptability</div>
                    </div>
                    <div class="analytics-card">
                        <h4>ğŸ² Randomness Level</h4>
                        <div id="randomness-level" class="metric-value">--</div>
                        <div id="randomness-status" class="metric-caption">Unpredictability</div>
                    </div>
                </div>

                <div class="panel move-distribution-panel">
                    <div class="panel-heading">
                        <h4 class="panel-title">ğŸ“ˆ Move Distribution Analysis</h4>
                    </div>
                    <div class="distribution-grid">
                        <div class="move-bar">
                            <div class="move-label">Paper (P)</div>
                            <div class="bar-container">
                                <div class="bar-fill paper" id="paper-fill"></div>
                            </div>
                            <div class="bar-percentage" id="paper-percent">0%</div>
                        </div>
                        <div class="move-bar">
                            <div class="move-label">Rock (R)</div>
                            <div class="bar-container">
                                <div class="bar-fill rock" id="rock-fill"></div>
                            </div>
                            <div class="bar-percentage" id="rock-percent">0%</div>
                        </div>
                        <div class="move-bar">
                            <div class="move-label">Scissor (S)</div>
                            <div class="bar-container">
                                <div class="bar-fill scissor" id="scissor-fill"></div>
                            </div>
                            <div class="bar-percentage" id="scissor-percent">0%</div>
                        </div>
                    </div>
                </div>

                <div class="advanced-actions">
                    <button class="btn primary" onclick="exportAnalytics('json')">ğŸ“„ Export JSON Report</button>
                    <button class="btn" onclick="refreshAnalytics()">ğŸ”„ Refresh Analytics</button>
                    <button class="btn outline" onclick="showDeveloperMetrics()">ğŸ”§ Developer Metrics</button>
                </div>
            </section>
        </div>
    </div>

    <div id="tournamentModal" class="tournament-modal" style="display: none;">
        <div class="tournament-content">
            <div class="tournament-header">
                <h2>ğŸ† Tournament Dashboard</h2>
                <button class="btn destructive" onclick="document.getElementById('tournamentModal').style.display='none'">âœ•</button>
            </div>
            <div class="tournament-grid">
                <div class="tournament-card">
                    <h3>ğŸ“Š Tournament Stats</h3>
                    <div class="tournament-stats">
                        <div class="stat-block">
                            <div id="totalPlayers" class="stat-value">0</div>
                            <div class="stat-label">Total Players</div>
                        </div>
                        <div class="stat-block">
                            <div id="totalMatches" class="stat-value">0</div>
                            <div class="stat-label">Completed Matches</div>
                        </div>
                    </div>
                </div>
                <div class="tournament-card">
                    <h3>â• Create Player</h3>
                    <div class="create-player">
                        <input type="text" id="newPlayerName" placeholder="Enter player name">
                        <button class="btn primary" onclick="createTournamentPlayer()">Create</button>
                    </div>
                </div>
            </div>
            <div class="tournament-grid">
                <div class="tournament-card">
                    <h3>ğŸ… Leaderboard</h3>
                    <div id="leaderboard" class="leaderboard"></div>
                </div>
                <div class="tournament-card">
                    <h3>âš”ï¸ Quick Match</h3>
                    <p>Select two players for a quick match</p>
                    <div class="quick-match">
                        <input type="text" id="player1Name" placeholder="Player 1 name">
                        <input type="text" id="player2Name" placeholder="Player 2 name">
                    </div>
                    <button class="btn primary" onclick="createQuickMatch()">ğŸ® Start Match</button>
                </div>
            </div>
        </div>
    </div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        console.log('Main page script loading...');
        
        // Global variables (will be updated from dropdown values on page load)
        let currentDifficulty = 'random';  // Default fallback
        let currentStrategy = 'balanced';  // Match dropdown default
        let currentPersonality = 'neutral';  // Match dropdown default
        
        // Chart variables
        let moveDistributionChart = null;
        let winRateTrendChart = null;
        let strategyTimelineChart = null;
        let modelPredictionChart = null;
        let modelAccuracyChart = null;
        let confidenceTrendChart = null;
        
        // Initialize charts when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing charts...');
            
            // Get actual dropdown values instead of relying on template variables
            currentDifficulty = document.getElementById('difficulty').value;
            currentStrategy = document.getElementById('strategy').value;
            currentPersonality = document.getElementById('personality').value;
            
            console.log('Initial dropdown values:', {
                difficulty: currentDifficulty,
                strategy: currentStrategy,
                personality: currentPersonality
            });
            
            setTimeout(initializeCharts, 100); // Small delay to ensure DOM is ready
            updateStatusDisplay();
            applyPersonalityTheme(currentPersonality);
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
            setTimeout(() => updateRobotConversation(currentPersonality, 'start'), 200);
        });
        
        // Keyboard controls
        document.addEventListener('keydown', function(e) {
            console.log('Key pressed:', e.key);
            if (e.key === 'p' || e.key === 'P') submitMove('paper');
            if (e.key === 'r' || e.key === 'R') submitMove('stone'); // Rock = Stone
            if (e.key === 's' || e.key === 'S') submitMove('scissor');
        });
        
        // Game functions
        function submitMove(move) {
            console.log('submitMove called with:', move);
            
            // Reset the battle arena for new round
            resetMoveDisplay();
            
            const payload = {
                move: move,
                difficulty: currentDifficulty,
                strategy: currentStrategy,
                personality: currentPersonality
            };
            
            console.log('Sending payload:', payload);
            
            fetch('/play', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            })
            .then(res => {
                console.log('Response status:', res.status);
                return res.json();
            })
            .then(data => {
                console.log('Received data:', data);
                updateUI(data);
            })
            .catch(error => {
                console.error('Error:', error);
                document.getElementById('result').innerHTML = 
                    '<p style="color: red;">Error: ' + error.message + '</p>';
            });
        }
        
        function updateUI(data) {
            console.log('Updating UI with:', data);
            
            // Safely get the last human move
            const lastHumanMove = data.human_history && data.human_history.length > 0 
                ? data.human_history[data.human_history.length-1] 
                : 'unknown';
            
            // Safely get the robot move
            const robotMove = data.robot_move || 'unknown';
            
            // Safely get the result
            const result = data.result ? String(data.result) : 'unknown';
            
            // Update result
            document.getElementById('result').innerHTML = 
                '<h3>Round ' + (data.round || 0) + ' Results</h3>' +
                '<p>You played: <strong>' + lastHumanMove.toUpperCase() + '</strong></p>' +
                '<p>Computer played: <strong>' + robotMove.toUpperCase() + '</strong></p>' +
                '<p>Result: <strong>' + result.toUpperCase() + '</strong></p>';
            
            // Update stats safely
            const stats = data.stats || {};
            document.getElementById('rounds').textContent = data.round || 0;
            document.getElementById('human-wins').textContent = stats.human_win || 0;
            document.getElementById('robot-wins').textContent = stats.robot_win || 0;
            document.getElementById('ties').textContent = stats.tie || 0;
            
            // Update recent history safely
            const recentHuman = data.human_history ? data.human_history.slice(-10).join(', ') : '';
            const recentRobot = data.robot_history ? data.robot_history.slice(-10).join(', ') : '';
            document.getElementById('recent-human').textContent = recentHuman;
            document.getElementById('recent-robot').textContent = recentRobot;
            
            // Update strategy display
            if (data.current_strategy) {
                const strategy = String(data.current_strategy);
                document.getElementById('current-strategy-text').textContent = 
                    strategy.charAt(0).toUpperCase() + strategy.slice(1);
            }
            
            // Auto-refresh coaching tips every 5 rounds
            if (data.round && data.round > 0 && data.round % 5 === 0) {
                setTimeout(refreshCoachingTips, 500); // Small delay to ensure data is processed
            }
            
            // Update analytics dashboard
            updateAnalyticsDashboard(data);
            
            // Update charts
            updateCharts(data);
            
            // Update move display window
            updateMoveDisplay(lastHumanMove, robotMove, result);
            
            // Update robot conversation based on result
            const conversationEventType = result === 'human' ? 'lose' : result === 'robot' ? 'win' : 'tie';
            setTimeout(() => {
                updateRobotConversation(currentPersonality, conversationEventType, {
                    humanMove: lastHumanMove,
                    robotMove: robotMove,
                    round: data.round
                });
            }, 800); // Delay to let move display finish
        }
        
        // Move Display Window Functions
        function updateMoveDisplay(humanMove, robotMove, result) {
            // Update human move
            updatePlayerMove('human', humanMove);
            
            // Update robot move with a shorter delay for faster loading
            setTimeout(() => {
                updatePlayerMove('robot', robotMove);
                // Show result immediately after robot move is displayed
                setTimeout(() => {
                    showRoundResult(result, humanMove, robotMove);
                }, 150);
            }, 200);
        }
        
        function updatePlayerMove(player, move) {
            const moveImg = document.getElementById(player + '-move-img');
            const moveText = document.getElementById(player + '-move-text');
            
            if (move && move !== 'unknown') {
                // Set the correct image
                const imageMap = {
                    'stone': '/static/stone.png',
                    'paper': '/static/paper.png',
                    'scissor': '/static/scissor.png'
                };
                
                moveImg.src = imageMap[move.toLowerCase()] || '/static/paper.png';
                moveImg.style.display = 'block';
                moveText.textContent = move.charAt(0).toUpperCase() + move.slice(1);
            } else {
                moveImg.style.display = 'none';
                moveText.textContent = player === 'human' ? 'Choose your move' : 'Thinking...';
            }
        }
        
        function showRoundResult(result, humanMove, robotMove) {
            const resultDiv = document.getElementById('round-result');
            const humanDisplay = document.getElementById('human-move-display');
            const robotDisplay = document.getElementById('robot-move-display');
            
            // Reset borders
            humanDisplay.style.border = '2px solid transparent';
            robotDisplay.style.border = '2px solid transparent';
            
            // Show result and highlight winner
            if (result === 'human') {
                resultDiv.textContent = 'ğŸ‰ You Win!';
                resultDiv.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
                resultDiv.style.color = 'white';
                humanDisplay.style.border = '2px solid #28a745';
                humanDisplay.style.boxShadow = '0 0 15px rgba(40, 167, 69, 0.4)';
            } else if (result === 'robot') {
                resultDiv.textContent = 'ğŸ¤– Robot Wins!';
                resultDiv.style.background = 'linear-gradient(135deg, #dc3545, #e83e8c)';
                resultDiv.style.color = 'white';
                robotDisplay.style.border = '2px solid #dc3545';
                robotDisplay.style.boxShadow = '0 0 15px rgba(220, 53, 69, 0.4)';
            } else {
                resultDiv.textContent = 'ğŸ¤ It\'s a Tie!';
                resultDiv.style.background = 'linear-gradient(135deg, #ffc107, #fd7e14)';
                resultDiv.style.color = 'white';
                humanDisplay.style.border = '2px solid #ffc107';
                robotDisplay.style.border = '2px solid #ffc107';
            }
            
            resultDiv.style.display = 'block';
            
            // Don't auto-reset - keep result until next move
        }
        
        function resetMoveDisplay() {
            // Hide images and reset text
            document.getElementById('human-move-img').style.display = 'none';
            document.getElementById('robot-move-img').style.display = 'none';
            document.getElementById('human-move-text').textContent = 'Choose your move';
            document.getElementById('robot-move-text').textContent = 'Thinking...';
            document.getElementById('round-result').style.display = 'none';
            
            // Reset borders and shadows
            const humanDisplay = document.getElementById('human-move-display');
            const robotDisplay = document.getElementById('robot-move-display');
            humanDisplay.style.border = '2px solid transparent';
            robotDisplay.style.border = '2px solid transparent';
            humanDisplay.style.boxShadow = 'none';
            robotDisplay.style.boxShadow = 'none';
        }
        
        // Robot Character Visualization Functions
        function updateRobotCharacter(difficulty, strategy, personality) {
            console.log('updateRobotCharacter called with:', difficulty, strategy, personality);
            updateRobotAvatar(difficulty, personality);
            updateStrategySymbol(strategy);
            updateRobotInfo(difficulty, strategy, personality);
        }
        
        function updateRobotAvatar(difficulty, personality) {
            const avatar = document.getElementById('robot-avatar');
            console.log('updateRobotAvatar - element found:', avatar, 'difficulty:', difficulty, 'personality:', personality);
            
            if (!avatar) {
                console.error('robot-avatar element not found!');
                return;
            }
            
            // Personality character mapping
            const personalityChars = {
                'neutral': 'ğŸ¤–',
                'berserker': 'ğŸ’€',
                'guardian': 'ğŸ›¡ï¸', 
                'chameleon': 'ğŸ¦',
                'professor': 'ğŸ“',
                'wildcard': 'ğŸƒ',
                'mirror': 'ğŸª',
                'balanced': 'ğŸ¤–'
            };
            
            // Difficulty-based background shading
            const difficultyStyles = {
                'random': {
                    background: 'linear-gradient(135deg, #e8f5e8, #d4edda)',
                    border: '3px solid #28a745'
                },
                'frequency': {
                    background: 'linear-gradient(135deg, #fff3cd, #ffeaa7)',
                    border: '3px solid #ffc107'
                },
                'markov': {
                    background: 'linear-gradient(135deg, #f8d7da, #f5b7b1)',
                    border: '3px solid #dc3545'
                },
                'enhanced': {
                    background: 'linear-gradient(135deg, #f3e5f5, #e1bee7)',
                    border: '3px solid #9c27b0'
                },
                'lstm': {
                    background: 'linear-gradient(135deg, #2c2c2c, #1a1a1a)',
                    border: '3px solid #6f42c1'
                }
            };
            
            // Update character
            const char = personalityChars[personality] || 'ğŸ¤–';
            console.log('Setting avatar char:', char);
            avatar.textContent = char;
            
            // Update styling
            const style = difficultyStyles[difficulty] || difficultyStyles['random'];
            console.log('Setting avatar style:', style);
            avatar.style.background = style.background;
            avatar.style.border = style.border;
        }
        
        function updateStrategySymbol(strategy) {
            const symbolElement = document.getElementById('strategy-symbol');
            console.log('updateStrategySymbol - element found:', symbolElement, 'strategy:', strategy);
            
            if (!symbolElement) {
                console.error('strategy-symbol element not found!');
                return;
            }
            
            // Strategy symbol mapping
            const strategySymbols = {
                'random': 'ğŸ²',
                'frequency': 'ğŸ“Š',
                'pattern': 'ğŸ”„',
                'markov': 'ğŸ§ ',
                'minimax': 'âš”ï¸',
                'lstm': 'ğŸ¤–',
                'balanced': 'âš–ï¸',
                'to_win': 'âš”ï¸',
                'not_to_lose': 'ğŸ›¡ï¸'
            };
            
            const symbol = strategySymbols[strategy] || 'âš”ï¸';
            console.log('Setting symbol to:', symbol);
            symbolElement.textContent = symbol;
        }
        
        function updateRobotInfo(difficulty, strategy, personality) {
            console.log('updateRobotInfo called with:', difficulty, strategy, personality);
            
            // Generate robot name based on personality and difficulty
            const names = {
                'neutral': ['Standard', 'Basic', 'Default', 'Unit'],
                'berserker': ['Destroyer', 'Annihilator', 'Crusher', 'Devastator'],
                'guardian': ['Protector', 'Defender', 'Shield', 'Bulwark'],
                'chameleon': ['Shifter', 'Adapter', 'Morph', 'Mimic'],
                'professor': ['Analyst', 'Scholar', 'Calculator', 'Logic'],
                'wildcard': ['Chaos', 'Random', 'Surprise', 'Wildfire'],
                'mirror': ['Echo', 'Reflection', 'Shadow', 'Copy'],
                'balanced': ['Standard', 'Basic', 'Default', 'Unit']
            };
            
            const nameList = names[personality] || names['neutral'];
            const baseName = nameList[Math.floor(Math.random() * nameList.length)];
            const difficultyPrefix = {
                'random': 'Basic',
                'frequency': 'Junior', 
                'markov': 'Advanced',
                'enhanced': 'Master',
                'lstm': 'Legendary'
            };
            
            const difficultyNames = {
                'random': 'Random',
                'frequency': 'Frequency Analysis',
                'markov': 'Markov Chain',
                'enhanced': 'Enhanced ML',
                'lstm': 'LSTM Neural Network'
            };
            
            const strategyNames = {
                'balanced': 'Balanced',
                'to_win': 'Aggressive (To Win)',
                'not_to_lose': 'Defensive (Not to Lose)'
            };
            
            const personalityNames = {
                'neutral': 'Neutral',
                'berserker': 'The Berserker',
                'guardian': 'The Guardian',
                'chameleon': 'The Chameleon',
                'professor': 'The Professor',
                'wildcard': 'The Wildcard',
                'mirror': 'The Mirror'
            };
            
            const robotName = `${difficultyPrefix[difficulty] || 'Basic'} ${baseName}`;
            
            console.log('Updating robot display with:', {
                robotName,
                difficulty: difficultyNames[difficulty] || difficulty,
                strategy: strategyNames[strategy] || strategy,
                personality: personalityNames[personality] || personality
            });
            
            // Update display with proper names
            const robotNameElement = document.getElementById('robot-name');
            const robotDifficultyElement = document.getElementById('robot-difficulty');
            const robotStrategyElement = document.getElementById('robot-strategy');
            const robotPersonalityElement = document.getElementById('robot-personality');
            
            if (robotNameElement) robotNameElement.textContent = robotName;
            if (robotDifficultyElement) robotDifficultyElement.textContent = difficultyNames[difficulty] || difficulty;
            if (robotStrategyElement) robotStrategyElement.textContent = strategyNames[strategy] || strategy;
            if (robotPersonalityElement) robotPersonalityElement.textContent = personalityNames[personality] || personality;
            
            console.log('Robot info updated successfully');
        }
        
        // Robot Conversation System Functions
        function updateRobotConversation(personality, eventType, data = {}) {
            const speechElement = document.getElementById('robot-speech');
            const moodElement = document.getElementById('robot-mood');
            const avatarElement = document.getElementById('conversation-avatar');
            
            const dialogue = generatePersonalityDialogue(personality, eventType, data);
            
            // Update speech with typing effect
            typeMessage(speechElement, dialogue.message);
            
            // Update mood and avatar
            moodElement.textContent = dialogue.mood;
            avatarElement.textContent = dialogue.avatar;
        }
        
        function generatePersonalityDialogue(personality, eventType, data) {
            const dialogues = {
                'berserker': {
                    'start': {
                        messages: ["CRUSH YOUR ENEMIES!", "No mercy! Let's fight!", "I will dominate this battle!", "Prepare for destruction!"],
                        mood: "ğŸ’€ Bloodthirsty",
                        avatar: "ğŸ’€"
                    },
                    'win': {
                        messages: ["VICTORY IS MINE!", "Another victim falls!", "Bow before my might!", "Total annihilation!"],
                        mood: "ğŸ‘¹ Triumphant",
                        avatar: "ğŸ‘¹"
                    },
                    'lose': {
                        messages: ["IMPOSSIBLE! I demand a rematch!", "This rage fuels my power!", "You got lucky this time!", "I will have my revenge!"],
                        mood: "ğŸ˜¡ Furious",
                        avatar: "ğŸ˜¡"
                    },
                    'tie': {
                        messages: ["We're equally matched!", "The battle continues!", "Neither yields!", "This proves nothing!"],
                        mood: "âš”ï¸ Intense",
                        avatar: "âš”ï¸"
                    }
                },
                'guardian': {
                    'start': {
                        messages: ["I shall protect my honor!", "Defense is the best strategy!", "Stand firm and endure!", "My shield is unbreakable!"],
                        mood: "ğŸ›¡ï¸ Steadfast",
                        avatar: "ğŸ›¡ï¸"
                    },
                    'win': {
                        messages: ["A well-defended victory!", "Patience and defense prevail!", "Honor is preserved!", "The shield holds strong!"],
                        mood: "ğŸ† Honorable",
                        avatar: "ğŸ†"
                    },
                    'lose': {
                        messages: ["I fought with honor!", "Sometimes the shield fails...", "Your strategy was admirable!", "I must strengthen my defense!"],
                        mood: "ğŸ’ª Resolute",
                        avatar: "ğŸ’ª"
                    },
                    'tie': {
                        messages: ["A noble stalemate!", "Both warriors show courage!", "Evenly matched defenses!", "Honor to both sides!"],
                        mood: "ğŸ¤ Respectful",
                        avatar: "ğŸ¤"
                    }
                },
                'chameleon': {
                    'start': {
                        messages: ["Adapting to your style...", "Let me observe your patterns!", "I'll match your energy!", "Time to blend strategies!"],
                        mood: "ğŸ¦ Adaptive",
                        avatar: "ğŸ¦"
                    },
                    'win': {
                        messages: ["Perfect adaptation!", "I mirrored your weakness!", "Flexibility wins again!", "Change is my strength!"],
                        mood: "ğŸ¯ Precise",
                        avatar: "ğŸ¯"
                    },
                    'lose': {
                        messages: ["Interesting... recalibrating!", "Your unpredictability impressed me!", "Time to adapt further!", "Learning from this defeat!"],
                        mood: "ğŸ”„ Evolving",
                        avatar: "ğŸ”„"
                    },
                    'tie': {
                        messages: ["We adapted to each other!", "Perfectly balanced strategies!", "Mutual adaptation!", "Synchronized thinking!"],
                        mood: "âš–ï¸ Balanced",
                        avatar: "âš–ï¸"
                    }
                },
                'professor': {
                    'start': {
                        messages: ["Let's analyze this scientifically!", "Fascinating tactical possibilities!", "Time for logical deduction!", "The data suggests..."],
                        mood: "ğŸ”¬ Analytical",
                        avatar: "ğŸ“"
                    },
                    'win': {
                        messages: ["Hypothesis confirmed!", "The calculations were correct!", "Logic prevails once again!", "A predictable outcome!"],
                        mood: "ğŸ§  Satisfied",
                        avatar: "ğŸ§ "
                    },
                    'lose': {
                        messages: ["Intriguing! An anomaly to study!", "Unexpected variables detected!", "This requires further analysis!", "Statistical outlier noted!"],
                        mood: "ğŸ¤” Curious",
                        avatar: "ğŸ¤”"
                    },
                    'tie': {
                        messages: ["Statistically balanced outcome!", "Equilibrium achieved!", "Perfect probability distribution!", "Fascinating data point!"],
                        mood: "ğŸ“Š Logical",
                        avatar: "ğŸ“Š"
                    }
                },
                'wildcard': {
                    'start': {
                        messages: ["Chaos time! Expect anything!", "Rules? What rules?!", "Let's shake things up!", "Random madness incoming!"],
                        mood: "ğŸƒ Chaotic",
                        avatar: "ğŸƒ"
                    },
                    'win': {
                        messages: ["BOOM! Didn't see that coming!", "Chaos reigns supreme!", "Random victory dance!", "Unpredictability wins!"],
                        mood: "ğŸ‰ Ecstatic",
                        avatar: "ğŸ‰"
                    },
                    'lose': {
                        messages: ["Whoops! That was unexpected!", "Plot twist! You got me!", "Chaos works both ways!", "Random defeat... or is it?"],
                        mood: "ğŸ¤ª Amused",
                        avatar: "ğŸ¤ª"
                    },
                    'tie': {
                        messages: ["What are the odds?!", "Chaos creates balance!", "Perfectly random outcome!", "Even randomness has patterns!"],
                        mood: "ğŸ² Surprised",
                        avatar: "ğŸ²"
                    }
                },
                'mirror': {
                    'start': {
                        messages: ["I reflect your every move!", "Mirror mirror on the wall...", "Your style becomes mine!", "Copying... initializing..."],
                        mood: "ğŸª Mirroring",
                        avatar: "ğŸª"
                    },
                    'win': {
                        messages: ["I became you, but better!", "Perfect reflection achieved!", "Your own moves defeated you!", "Mirror mastery complete!"],
                        mood: "âœ¨ Reflected",
                        avatar: "âœ¨"
                    },
                    'lose': {
                        messages: ["You broke the mirror!", "Reflection incomplete...", "My copy wasn't perfect!", "Time to re-calibrate reflection!"],
                        mood: "ğŸ’« Fragmented",
                        avatar: "ğŸ’«"
                    },
                    'tie': {
                        messages: ["Perfect mirror match!", "Two reflections collide!", "We are the same!", "Mirror meets mirror!"],
                        mood: "ğŸ”„ Synchronized",
                        avatar: "ğŸ”„"
                    }
                },
                'neutral': {
                    'start': {
                        messages: ["Ready for battle? Let's play!", "I'll analyze your patterns.", "May the best strategy win!", "Game on!"],
                        mood: "ğŸ¤– Ready",
                        avatar: "ğŸ¤–"
                    },
                    'win': {
                        messages: ["Good game! I predicted correctly.", "My analysis paid off!", "Strategy successful!", "Well played!"],
                        mood: "ğŸ˜Š Satisfied",
                        avatar: "ğŸ˜Š"
                    },
                    'lose': {
                        messages: ["Nice move! You got me there.", "Impressive strategy!", "I'll adapt for next time.", "You outplayed me!"],
                        mood: "ğŸ¤” Analyzing",
                        avatar: "ğŸ¤”"
                    },
                    'tie': {
                        messages: ["Great minds think alike!", "Even match!", "Balanced strategies!", "Perfect tie!"],
                        mood: "âš–ï¸ Balanced",
                        avatar: "âš–ï¸"
                    }
                }
            };
            
            const personalityData = dialogues[personality] || dialogues['neutral'] || dialogues['berserker'];
            const eventData = personalityData[eventType] || personalityData['start'];
            
            return {
                message: eventData.messages[Math.floor(Math.random() * eventData.messages.length)],
                mood: eventData.mood,
                avatar: eventData.avatar
            };
        }
        
        function typeMessage(element, message) {
            element.textContent = '';
            let i = 0;
            const typingSpeed = 30; // ms per character
            
            function typeChar() {
                if (i < message.length) {
                    element.textContent += message.charAt(i);
                    i++;
                    setTimeout(typeChar, typingSpeed);
                }
            }
            
            typeChar();
        }
        
        // Advanced Analytics Functions
        function updateAnalyticsDashboard(data) {
            if (!data.human_history || data.human_history.length === 0) return;
            
            const history = data.human_history;
            const totalMoves = history.length;
            
            // Calculate move distribution
            const paperCount = history.filter(m => m === 'paper').length;
            const stoneCount = history.filter(m => m === 'stone').length;
            const scissorCount = history.filter(m => m === 'scissor').length;
            
            const paperPercent = ((paperCount / totalMoves) * 100).toFixed(1);
            const stonePercent = ((stoneCount / totalMoves) * 100).toFixed(1);
            const scissorPercent = ((scissorCount / totalMoves) * 100).toFixed(1);
            
            // Update move distribution bars
            document.getElementById('paper-fill').style.width = paperPercent + '%';
            document.getElementById('rock-fill').style.width = stonePercent + '%';
            document.getElementById('scissor-fill').style.width = scissorPercent + '%';
            
            document.getElementById('paper-percent').textContent = paperPercent + '%';
            document.getElementById('rock-percent').textContent = stonePercent + '%';
            document.getElementById('scissor-percent').textContent = scissorPercent + '%';
            
            // Calculate predictability score
            const maxPercent = Math.max(paperPercent, stonePercent, scissorPercent);
            const predictabilityScore = maxPercent;
            document.getElementById('predictability-score').textContent = predictabilityScore + '%';
            
            let predictabilityStatus = 'Highly Unpredictable';
            if (predictabilityScore > 50) predictabilityStatus = 'Somewhat Predictable';
            if (predictabilityScore > 70) predictabilityStatus = 'Very Predictable';
            document.getElementById('predictability-status').textContent = predictabilityStatus;
            
            // Calculate recent win rate trend
            const recentGames = Math.min(10, data.round);
            const recentWins = data.stats ? data.stats.human_win : 0;
            const winRate = data.round > 0 ? ((recentWins / data.round) * 100).toFixed(1) : 0;
            document.getElementById('win-rate-trend').textContent = winRate + '%';
            
            // Calculate randomness level (entropy)
            const p1 = paperCount / totalMoves;
            const p2 = stoneCount / totalMoves;
            const p3 = scissorCount / totalMoves;
            let entropy = 0;
            if (p1 > 0) entropy -= p1 * Math.log2(p1);
            if (p2 > 0) entropy -= p2 * Math.log2(p2);
            if (p3 > 0) entropy -= p3 * Math.log2(p3);
            const randomnessPercent = ((entropy / Math.log2(3)) * 100).toFixed(1);
            document.getElementById('randomness-level').textContent = randomnessPercent + '%';
            
            let randomnessStatus = 'Low Randomness';
            if (randomnessPercent > 60) randomnessStatus = 'Medium Randomness';
            if (randomnessPercent > 80) randomnessStatus = 'High Randomness';
            document.getElementById('randomness-status').textContent = randomnessStatus;
            
            // Strategy changes (placeholder)
            document.getElementById('strategy-changes-count').textContent = Math.floor(data.round / 7) || 0;
        }
        
        function refreshAnalytics() {
            console.log('Refreshing analytics...');
            fetch('/history')
            .then(res => res.json())
            .then(data => {
                console.log('Analytics data received:', data);
                updateAnalyticsDashboard(data);
            })
            .catch(err => console.log('Analytics refresh failed:', err));
        }
        
        function updateStatusDisplay() {
            // Update the game status to show current AI configuration
            const strategyText = {
                'balanced': 'Balanced Strategy',
                'to_win': 'To Win (Aggressive)',
                'not_to_lose': 'Not to Lose (Defensive)'
            };
            
            const personalityText = {
                'neutral': 'Neutral Personality',
                'aggressive': 'Aggressive Personality',
                'defensive': 'Defensive Personality',
                'adaptive': 'Adaptive Personality',
                'chaotic': 'Chaotic Personality',
                'copycat': 'Copycat Personality'
            };
            
            console.log(`AI Config: ${currentDifficulty} + ${strategyText[currentStrategy]} + ${personalityText[currentPersonality]}`);
        }
        
        function applyPersonalityTheme(personality) {
            // Remove existing personality classes
            document.body.classList.remove('personality-aggressive', 'personality-defensive', 'personality-adaptive', 'personality-chaotic', 'personality-copycat');
            
            // Apply new personality theme
            if (personality !== 'neutral') {
                document.body.classList.add(`personality-${personality}`);
            }
            
            // Update UI elements based on personality
            const gameContainer = document.querySelector('.game-container');
            if (gameContainer) {
                const themes = {
                    'neutral': { borderColor: '#ddd', backgroundColor: '#fff' },
                    'aggressive': { borderColor: '#ff4444', backgroundColor: '#fff5f5' },
                    'defensive': { borderColor: '#4444ff', backgroundColor: '#f5f5ff' },
                    'adaptive': { borderColor: '#9944ff', backgroundColor: '#faf5ff' },
                    'chaotic': { borderColor: '#ff8844', backgroundColor: '#fff8f5' },
                    'copycat': { borderColor: '#44ff44', backgroundColor: '#f5fff5' }
                };
                
                const theme = themes[personality] || themes['neutral'];
                gameContainer.style.borderColor = theme.borderColor;
                gameContainer.style.backgroundColor = theme.backgroundColor;
            }
        }
        
        function exportAnalytics(format) {
            console.log('Exporting analytics in format:', format);
            fetch('/analytics/export?format=' + format)
            .then(res => res.blob())
            .then(blob => {
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = 'rps_analytics_' + new Date().toISOString().split('T')[0] + '.' + format;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
            })
            .catch(err => {
                console.log('Export failed, creating manual export:', err);
                // Fallback: create manual JSON export
                const analyticsData = {
                    timestamp: new Date().toISOString(),
                    total_games: parseInt(document.getElementById('rounds').textContent) || 0,
                    predictability_score: document.getElementById('predictability-score').textContent,
                    win_rate: document.getElementById('win-rate-trend').textContent,
                    randomness_level: document.getElementById('randomness-level').textContent,
                    move_distribution: {
                        paper: document.getElementById('paper-percent').textContent,
                        rock: document.getElementById('rock-percent').textContent,
                        scissor: document.getElementById('scissor-percent').textContent
                    }
                };
                const dataStr = JSON.stringify(analyticsData, null, 2);
                const dataBlob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(dataBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'rps_analytics_' + new Date().toISOString().split('T')[0] + '.json';
                a.click();
            });
        }
        
        function showDeveloperMetrics() {
            const metrics = {
                'Page Load Time': 'Fast',
                'API Response Time': 'Good',
                'JavaScript Errors': 'None',
                'Memory Usage': 'Normal',
                'Network Requests': 'Optimized'
            };
            
            let metricsHtml = '<h4>ğŸ”§ Developer Metrics Console</h4>';
            for (const [key, value] of Object.entries(metrics)) {
                metricsHtml += `<p><strong>${key}:</strong> ${value}</p>`;
            }
            metricsHtml += '<p><em>All systems operational</em></p>';
            
            alert('Developer Metrics:\n\n' + Object.entries(metrics).map(([k,v]) => `${k}: ${v}`).join('\n'));
        }
        
        // Chart Functions
        function initializeCharts() {
            console.log('Initializing charts...');
            try {
                // Move Distribution Pie Chart
                const moveCtx = document.getElementById('moveDistributionChart');
                if (moveCtx) {
                    moveDistributionChart = new Chart(moveCtx, {
                        type: 'pie',
                        data: {
                            labels: ['Paper (P)', 'Rock (R)', 'Scissor (S)'],
                            datasets: [{
                                data: [0, 0, 0],
                                backgroundColor: ['#4CAF50', '#FF9800', '#F44336'],
                                borderWidth: 2,
                                borderColor: '#fff'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                }
                
                // Win Rate Trend Line Chart
                const winCtx = document.getElementById('winRateTrendChart');
                if (winCtx) {
                    winRateTrendChart = new Chart(winCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Win Rate %',
                                data: [],
                                borderColor: '#1976D2',
                                backgroundColor: 'rgba(25, 118, 210, 0.1)',
                                fill: true,
                                tension: 0.3
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    ticks: {
                                        callback: function(value) {
                                            return value + '%';
                                        }
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
                
                // Strategy Timeline Bar Chart
                const strategyCtx = document.getElementById('strategyTimelineChart');
                if (strategyCtx) {
                    strategyTimelineChart = new Chart(strategyCtx, {
                        type: 'bar',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Strategy Usage',
                                data: [],
                                backgroundColor: '#9C27B0',
                                borderColor: '#7B1FA2',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
                
                // Model Prediction Chart
                const modelCtx = document.getElementById('modelPredictionChart');
                if (modelCtx) {
                    modelPredictionChart = new Chart(modelCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Human Move',
                                    data: [],
                                    borderColor: '#FF6384',
                                    backgroundColor: 'rgba(255, 99, 132, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    pointRadius: 4
                                },
                                {
                                    label: 'Robot Move',
                                    data: [],
                                    borderColor: '#36A2EB',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    pointRadius: 4
                                },
                                {
                                    label: 'Random Prediction',
                                    data: [],
                                    borderColor: '#FFCE56',
                                    backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2
                                },
                                {
                                    label: 'Frequency Prediction',
                                    data: [],
                                    borderColor: '#4BC0C0',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2
                                },
                                {
                                    label: 'Markov Prediction',
                                    data: [],
                                    borderColor: '#9966FF',
                                    backgroundColor: 'rgba(153, 102, 255, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2
                                },
                                {
                                    label: 'Enhanced Prediction',
                                    data: [],
                                    borderColor: '#FF9F40',
                                    backgroundColor: 'rgba(255, 159, 64, 0.1)',
                                    fill: false,
                                    tension: 0.1,
                                    borderDash: [5, 5],
                                    pointRadius: 2
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            interaction: {
                                intersect: false,
                                mode: 'index'
                            },
                            plugins: {
                                legend: {
                                    position: 'top',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 10,
                                        font: {
                                            size: 11
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Move Number'
                                    }
                                },
                                y: {
                                    display: true,
                                    title: {
                                        display: true,
                                        text: 'Move Type'
                                    },
                                    min: -0.5,
                                    max: 2.5,
                                    ticks: {
                                        stepSize: 1,
                                        callback: function(value) {
                                            if (value === 0) return 'Scissor';
                                            if (value === 1) return 'Rock';
                                            if (value === 2) return 'Paper';
                                            return '';
                                        }
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Model Accuracy Comparison Chart
                const accuracyCtx = document.getElementById('modelAccuracyChart');
                if (accuracyCtx) {
                    modelAccuracyChart = new Chart(accuracyCtx, {
                        type: 'bar',
                        data: {
                            labels: ['Random', 'Frequency', 'Markov', 'Enhanced', 'LSTM'],
                            datasets: [{
                                label: 'Accuracy (%)',
                                data: [0, 0, 0, 0, 0],
                                backgroundColor: [
                                    'rgba(255, 206, 86, 0.8)',
                                    'rgba(75, 192, 192, 0.8)',
                                    'rgba(153, 102, 255, 0.8)',
                                    'rgba(255, 159, 64, 0.8)',
                                    'rgba(54, 162, 235, 0.8)'
                                ],
                                borderColor: [
                                    'rgba(255, 206, 86, 1)',
                                    'rgba(75, 192, 192, 1)',
                                    'rgba(153, 102, 255, 1)',
                                    'rgba(255, 159, 64, 1)',
                                    'rgba(54, 162, 235, 1)'
                                ],
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { display: false }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    title: {
                                        display: true,
                                        text: 'Accuracy (%)'
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Confidence Trend Chart
                const confidenceCtx = document.getElementById('confidenceTrendChart');
                if (confidenceCtx) {
                    confidenceTrendChart = new Chart(confidenceCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [
                                {
                                    label: 'Random',
                                    data: [],
                                    borderColor: 'rgba(255, 206, 86, 1)',
                                    backgroundColor: 'rgba(255, 206, 86, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'Frequency',
                                    data: [],
                                    borderColor: 'rgba(75, 192, 192, 1)',
                                    backgroundColor: 'rgba(75, 192, 192, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'Markov',
                                    data: [],
                                    borderColor: 'rgba(153, 102, 255, 1)',
                                    backgroundColor: 'rgba(153, 102, 255, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'Enhanced',
                                    data: [],
                                    borderColor: 'rgba(255, 159, 64, 1)',
                                    backgroundColor: 'rgba(255, 159, 64, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                },
                                {
                                    label: 'LSTM',
                                    data: [],
                                    borderColor: 'rgba(54, 162, 235, 1)',
                                    backgroundColor: 'rgba(54, 162, 235, 0.1)',
                                    fill: false,
                                    tension: 0.4
                                }
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 10,
                                        font: { size: 10 }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Move Number'
                                    }
                                },
                                y: {
                                    beginAtZero: true,
                                    max: 1,
                                    title: {
                                        display: true,
                                        text: 'Confidence'
                                    }
                                }
                            }
                        }
                    });
                }
                
                console.log('Charts initialized successfully');
            } catch (error) {
                console.error('Error initializing charts:', error);
            }
        }
        
        function updateCharts(data) {
            if (!data.human_history || data.human_history.length === 0) return;
            
            try {
                // Update Move Distribution Chart
                if (moveDistributionChart) {
                    const history = data.human_history;
                    const paperCount = history.filter(m => m === 'paper').length;
                    const stoneCount = history.filter(m => m === 'stone').length;
                    const scissorCount = history.filter(m => m === 'scissor').length;
                    
                    moveDistributionChart.data.datasets[0].data = [paperCount, stoneCount, scissorCount];
                    moveDistributionChart.update('none'); // No animation for performance
                }
                
                // Update Win Rate Trend Chart
                if (winRateTrendChart && data.round > 0) {
                    const winRate = data.stats ? ((data.stats.human_win / data.round) * 100).toFixed(1) : 0;
                    
                    // Keep last 20 data points
                    if (winRateTrendChart.data.labels.length >= 20) {
                        winRateTrendChart.data.labels.shift();
                        winRateTrendChart.data.datasets[0].data.shift();
                    }
                    
                    winRateTrendChart.data.labels.push(`R${data.round}`);
                    winRateTrendChart.data.datasets[0].data.push(parseFloat(winRate));
                    winRateTrendChart.update('none');
                }
                
                // Update Strategy Timeline Chart (simplified)
                if (strategyTimelineChart) {
                    const strategies = ['Analyzing', 'Random', 'Frequency', 'Markov', 'Enhanced'];
                    const counts = strategies.map(() => Math.floor(Math.random() * data.round / 5 + 1));
                    
                    strategyTimelineChart.data.labels = strategies;
                    strategyTimelineChart.data.datasets[0].data = counts;
                    strategyTimelineChart.update('none');
                }
                
                // Update Model Prediction Chart
                if (modelPredictionChart && data.human_history && data.robot_history) {
                    const moveToNumber = (move) => {
                        if (move === 'paper') return 2;
                        if (move === 'stone' || move === 'rock') return 1;
                        if (move === 'scissor') return 0;
                        return null;
                    };
                    
                    const humanData = data.human_history.map(moveToNumber);
                    const robotData = data.robot_history.map(moveToNumber);
                    
                    // Use real model predictions from backend
                    const modelPreds = data.model_predictions_history || {};
                    const randomPreds = (modelPreds.random || []).map(moveToNumber);
                    const frequencyPreds = (modelPreds.frequency || []).map(moveToNumber);
                    const markovPreds = (modelPreds.markov || []).map(moveToNumber);
                    const enhancedPreds = (modelPreds.enhanced || []).map(moveToNumber);
                    
                    const labels = Array.from({length: humanData.length}, (_, i) => i + 1);
                    
                    modelPredictionChart.data.labels = labels;
                    modelPredictionChart.data.datasets[0].data = humanData; // Human moves
                    modelPredictionChart.data.datasets[1].data = robotData; // Robot moves
                    modelPredictionChart.data.datasets[2].data = randomPreds; // Random predictions
                    modelPredictionChart.data.datasets[3].data = frequencyPreds; // Frequency predictions
                    modelPredictionChart.data.datasets[4].data = markovPreds; // Markov predictions
                    modelPredictionChart.data.datasets[5].data = enhancedPreds; // Enhanced predictions
                    
                    modelPredictionChart.update('none');
                }
                
                // Update Model Accuracy Chart
                if (modelAccuracyChart && data.accuracy) {
                    const accuracyData = [
                        data.accuracy.random || 0,
                        data.accuracy.frequency || 0, 
                        data.accuracy.markov || 0,
                        data.accuracy.enhanced || 0,
                        data.accuracy.lstm || 0
                    ];
                    modelAccuracyChart.data.datasets[0].data = accuracyData;
                    modelAccuracyChart.update('none');
                }
                
                // Update Confidence Trend Chart
                if (confidenceTrendChart && data.confidence !== undefined) {
                    const moveNum = data.round;
                    
                    // Simulate confidence values for different models (in real implementation, track actual confidence)
                    const confidenceValues = {
                        random: 0.33,
                        frequency: Math.min(0.8, 0.3 + (data.round * 0.02)),
                        markov: Math.min(0.85, 0.4 + (data.round * 0.015)),
                        enhanced: data.confidence || 0.5,
                        lstm: Math.min(0.9, 0.5 + (data.round * 0.01))
                    };
                    
                    if (confidenceTrendChart.data.labels.length > 20) {
                        // Keep only last 20 moves for performance
                        confidenceTrendChart.data.labels.shift();
                        confidenceTrendChart.data.datasets.forEach(dataset => dataset.data.shift());
                    }
                    
                    confidenceTrendChart.data.labels.push(moveNum);
                    confidenceTrendChart.data.datasets[0].data.push(confidenceValues.random);
                    confidenceTrendChart.data.datasets[1].data.push(confidenceValues.frequency);
                    confidenceTrendChart.data.datasets[2].data.push(confidenceValues.markov);
                    confidenceTrendChart.data.datasets[3].data.push(confidenceValues.enhanced);
                    confidenceTrendChart.data.datasets[4].data.push(confidenceValues.lstm);
                    confidenceTrendChart.update('none');
                }
                
                // Update Model Metrics Table
                updateModelMetrics(data);
                
                // Update Recommended Strategy
                updateRecommendedStrategy(data);
                
            } catch (error) {
                console.error('Error updating charts:', error);
            }
        }
        
        // Model Metrics Functions
        function updateModelMetrics(data) {
            const metricsContainer = document.getElementById('modelMetricsTable');
            if (!metricsContainer || !data.accuracy) return;
            
            const models = [
                { name: 'Random', key: 'random', color: '#FFCE56' },
                { name: 'Frequency', key: 'frequency', color: '#4BC0C0' },
                { name: 'Markov', key: 'markov', color: '#9966FF' },
                { name: 'Enhanced', key: 'enhanced', color: '#FF9F40' },
                { name: 'LSTM Neural', key: 'lstm', color: '#36A2EB' }
            ];
            
            metricsContainer.innerHTML = models.map(model => {
                const accuracy = data.accuracy[model.key] || 0;
                const correct = data.correct_predictions?.[model.key] || 0;
                const total = data.total_predictions?.[model.key] || 0;
                
                return `
                    <div style="background: linear-gradient(135deg, ${model.color}20, ${model.color}10); border-left: 4px solid ${model.color}; padding: 15px; border-radius: 8px;">
                        <h6 style="margin: 0 0 8px 0; color: #333; font-weight: bold;">${model.name} Strategy</h6>
                        <div style="font-size: 24px; font-weight: bold; color: ${model.color}; margin-bottom: 5px;">${accuracy.toFixed(1)}%</div>
                        <div style="color: #666; font-size: 12px;">
                            Predictions: ${correct}/${total}<br>
                            Status: ${accuracy > 60 ? 'ğŸŸ¢ Excellent' : accuracy > 40 ? 'ğŸŸ¡ Good' : 'ğŸ”´ Needs Improvement'}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateRecommendedStrategy(data) {
            const recommendationEl = document.getElementById('recommendedStrategy');
            if (!recommendationEl || !data.accuracy) return;
            
            const accuracies = data.accuracy;
            const bestModel = Object.keys(accuracies).reduce((best, current) => 
                (accuracies[current] || 0) > (accuracies[best] || 0) ? current : best
            );
            
            const bestAccuracy = accuracies[bestModel] || 0;
            const modelNames = {
                'random': 'Random Strategy',
                'frequency': 'Frequency Analysis',
                'markov': 'Markov Chain',
                'enhanced': 'Enhanced ML',
                'to_win': 'To Win (Aggressive)',
                'not_to_lose': 'Not to Lose (Defensive)'
            };
            
            const recommendation = bestAccuracy > 60 ? 
                `ğŸ† ${modelNames[bestModel]} (${bestAccuracy.toFixed(1)}% accuracy)` :
                `ğŸ”„ Continue analyzing patterns (Best: ${modelNames[bestModel]} at ${bestAccuracy.toFixed(1)}%)`;
                
            recommendationEl.innerHTML = `
                <div style="color: ${bestAccuracy > 60 ? '#4CAF50' : '#FF9800'};">
                    ${recommendation}
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    ${data.round < 10 ? 'Play more rounds for better analysis' : 'Pattern analysis complete'}
                </div>
            `;
        }
        
        // Tournament Management Functions
        function showTournamentDashboard() {
            fetch('/tournament')
            .then(res => res.json())
            .then(data => {
                updateTournamentDashboard(data);
                document.getElementById('tournamentModal').style.display = 'block';
            })
            .catch(err => console.error('Error fetching tournament data:', err));
        }
        
        function updateTournamentDashboard(data) {
            // Update leaderboard
            const leaderboardHtml = data.leaderboard.map((player, index) => `
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: ${index < 3 ? '#f0f8ff' : '#f9f9f9'}; margin: 5px 0; border-radius: 5px;">
                    <div>
                        <span style="font-weight: bold; color: ${index === 0 ? '#FFD700' : index === 1 ? '#C0C0C0' : index === 2 ? '#CD7F32' : '#666'};">
                            #${index + 1}
                        </span>
                        ${player.name}
                    </div>
                    <div style="text-align: right;">
                        <div style="font-weight: bold;">${Math.round(player.elo_rating)}</div>
                        <div style="font-size: 12px; color: #666;">${player.wins}W-${player.losses}L</div>
                    </div>
                </div>
            `).join('');
            
            document.getElementById('leaderboard').innerHTML = leaderboardHtml;
            
            // Update stats
            document.getElementById('totalPlayers').textContent = data.total_players;
            document.getElementById('totalMatches').textContent = data.total_matches;
        }
        
        function createTournamentPlayer() {
            const name = document.getElementById('newPlayerName').value.trim();
            if (!name) {
                alert('Please enter a player name');
                return;
            }
            
            fetch('/tournament/player', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({name: name})
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    document.getElementById('newPlayerName').value = '';
                    showTournamentDashboard(); // Refresh dashboard
                    alert(`Player "${data.player.name}" created successfully!`);
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(err => {
                console.error('Error creating player:', err);
                alert('Error creating player');
            });
        }
        
        function createQuickMatch() {
            const player1 = document.getElementById('player1Name').value.trim();
            const player2 = document.getElementById('player2Name').value.trim();
            
            if (!player1 || !player2) {
                alert('Please enter both player names');
                return;
            }
            
            fetch('/tournament/match', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    player1_name: player1,
                    player2_name: player2
                })
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    alert(`Match created between ${player1} and ${player2}!`);
                    document.getElementById('player1Name').value = '';
                    document.getElementById('player2Name').value = '';
                    // You could redirect to a match interface here
                } else {
                    alert('Error: ' + data.error);
                }
            })
            .catch(err => {
                console.error('Error creating match:', err);
                alert('Error creating match');
            });
        }
        
        // Coaching Functions
        function refreshCoachingTips() {
            console.log('Refreshing coaching tips...');
            fetch('/coaching')
            .then(res => res.json())
            .then(data => {
                console.log('Coaching data received:', data);
                updateCoachingTips(data);
            })
            .catch(err => {
                console.log('Coaching tips unavailable:', err);
                document.getElementById('coaching-tips-list').innerHTML = 
                    '<p style="color: #666; font-style: italic;">Coaching tips will be available after more games.</p>';
            });
        }
        
        function updateCoachingTips(coachingData) {
            const tipsContainer = document.getElementById('coaching-tips-list');
            const experimentsContainer = document.getElementById('experiments-list');
            const insightsContainer = document.getElementById('insights-content');
            const insightsSummary = document.getElementById('insights-summary');
            
            // Update tips
            if (coachingData.coaching_tips && coachingData.coaching_tips.length > 0) {
                const tipsHtml = coachingData.coaching_tips.map((tip, index) => 
                    `<div style="margin-bottom: 12px; padding: 10px; background: rgba(255,152,0,0.1); border-radius: 6px;">
                        <strong>${index + 1}.</strong> ${tip}
                    </div>`
                ).join('');
                tipsContainer.innerHTML = tipsHtml;
            } else {
                tipsContainer.innerHTML = '<p style="color: #666; font-style: italic;">Keep playing to get personalized tips!</p>';
            }
            
            // Update experiments
            if (coachingData.experiments && coachingData.experiments.length > 0) {
                const experimentsHtml = coachingData.experiments.map(exp => 
                    `<div style="margin-bottom: 15px; padding: 12px; background: rgba(76,175,80,0.1); border-radius: 6px;">
                        <strong style="color: #2e7d32;">${exp.name}</strong><br>
                        <small style="color: #388e3c;">${exp.description}</small><br>
                        <em style="font-size: 13px; color: #4caf50;">${exp.strategy}</em>
                    </div>`
                ).join('');
                experimentsContainer.innerHTML = experimentsHtml;
            } else {
                experimentsContainer.innerHTML = '<p style="color: #666; font-style: italic;">Experiment suggestions coming soon!</p>';
            }
            
            // Update insights (optional)
            if (coachingData.insights && Object.keys(coachingData.insights).length > 0) {
                const insights = coachingData.insights;
                let insightsHtml = '';
                
                if (insights.predictability !== undefined) {
                    const predPercent = (insights.predictability * 100).toFixed(1);
                    insightsHtml += `<p><strong>Predictability:</strong> ${predPercent}% - `;
                    insightsHtml += insights.predictability > 0.6 ? 'Too predictable!' : 'Good unpredictability';
                    insightsHtml += '</p>';
                }
                
                if (insights.pattern_type) {
                    insightsHtml += `<p><strong>Pattern Type:</strong> ${insights.pattern_type.replace('_', ' ')}</p>`;
                }
                
                if (insights.recent_performance) {
                    const winRate = (insights.recent_performance.win_rate * 100).toFixed(1);
                    insightsHtml += `<p><strong>Recent Win Rate:</strong> ${winRate}%</p>`;
                }
                
                if (insightsHtml) {
                    insightsContainer.innerHTML = insightsHtml;
                    insightsSummary.style.display = 'block';
                } else {
                    insightsSummary.style.display = 'none';
                }
            } else {
                insightsSummary.style.display = 'none';
            }
        }
        
        function setDifficulty() {
            currentDifficulty = document.getElementById('difficulty').value;
            console.log('Difficulty set to:', currentDifficulty);
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
        }
        
        function setStrategy() {
            currentStrategy = document.getElementById('strategy').value;
            console.log('Strategy set to:', currentStrategy);
            updateStatusDisplay();
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
        }
        
        function setPersonality() {
            currentPersonality = document.getElementById('personality').value;
            console.log('Personality set to:', currentPersonality);
            updateStatusDisplay();
            applyPersonalityTheme(currentPersonality);
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
            updateRobotConversation(currentPersonality, 'start');
        }
        
        // DEBUG: Test function to manually trigger robot update
        function testRobotUpdate() {
            console.log('=== MANUAL TEST TRIGGERED ===');
            const diff = document.getElementById('difficulty').value;
            const strat = document.getElementById('strategy').value;
            const pers = document.getElementById('personality').value;
            
            console.log('Current dropdown values:', { diff, strat, pers });
            console.log('Current JS variables:', { currentDifficulty, currentStrategy, currentPersonality });
            
            // Update variables
            currentDifficulty = diff;
            currentStrategy = strat;
            currentPersonality = pers;
            
            console.log('Calling updateRobotCharacter...');
            updateRobotCharacter(currentDifficulty, currentStrategy, currentPersonality);
        }
        
        
        function resetGame() {
            fetch('/reset', {method: 'POST'})
            .then(res => res.json())
            .then(() => location.reload())
            .catch(error => {
                console.error('Reset error:', error);
                location.reload();
            });
        }
        
        // ğŸ® ENHANCED REPLAY FUNCTIONS (New Feature #1)
        function saveCurrentReplay() {
            const name = prompt('Enter a name for this replay:', 'Game Session ' + new Date().toLocaleString());
            if (name) {
                const notes = prompt('Enter any notes (optional):', '');
                const formData = new FormData();
                formData.append('name', name);
                formData.append('notes', notes || '');
                
                fetch('/replay/save', {
                    method: 'POST',
                    body: formData
                })
                .then(res => res.json())
                .then(data => {
                    if (data.success) {
                        alert(`âœ… Replay saved successfully!\nSession ID: ${data.session_id}\nTotal rounds: ${data.total_rounds}`);
                    } else {
                        alert(`âŒ Failed to save replay: ${data.message}`);
                    }
                })
                .catch(err => {
                    alert('âŒ Error saving replay: ' + err.message);
                });
            }
        }
        
        console.log('Main page script loaded successfully');
    </script>
</body>
</html>